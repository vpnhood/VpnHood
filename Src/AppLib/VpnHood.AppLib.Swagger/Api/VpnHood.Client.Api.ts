//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    get( cancelToken?: CancelToken): Promise<AppAccount> {
        let url_ = this.baseUrl + "/api/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<AppAccount> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppAccount.fromJS(resultData200);
            return Promise.resolve<AppAccount>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppAccount>(null as any);
    }

    refresh( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    isSigninWithGoogleSupported( cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/is-signin-with-google-supported";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsSigninWithGoogleSupported(_response);
        });
    }

    protected processIsSigninWithGoogleSupported(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    signInWithGoogle( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/signin-with-google";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignInWithGoogle(_response);
        });
    }

    protected processSignInWithGoogle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    signOut( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/sign-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    listAccessKeys(subscriptionId: string, cancelToken?: CancelToken): Promise<string[]> {
        let url_ = this.baseUrl + "/api/account/subscriptions/{subscriptionId}/access-keys";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAccessKeys(_response);
        });
    }

    protected processListAccessKeys(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class AppClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    configure(configParams: ConfigParams, cancelToken?: CancelToken): Promise<AppData> {
        let url_ = this.baseUrl + "/api/app/configure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(configParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfigure(_response);
        });
    }

    protected processConfigure(response: AxiosResponse): Promise<AppData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppData.fromJS(resultData200);
            return Promise.resolve<AppData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppData>(null as any);
    }

    getConfig( cancelToken?: CancelToken): Promise<AppData> {
        let url_ = this.baseUrl + "/api/app/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConfig(_response);
        });
    }

    protected processGetConfig(response: AxiosResponse): Promise<AppData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppData.fromJS(resultData200);
            return Promise.resolve<AppData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppData>(null as any);
    }

    getState( cancelToken?: CancelToken): Promise<AppState> {
        let url_ = this.baseUrl + "/api/app/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetState(_response);
        });
    }

    protected processGetState(response: AxiosResponse): Promise<AppState> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppState.fromJS(resultData200);
            return Promise.resolve<AppState>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppState>(null as any);
    }

    connect(clientProfileId?: string | null | undefined, serverLocation?: string | null | undefined, planId?: ConnectPlanId | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/connect?";
        if (clientProfileId !== undefined && clientProfileId !== null)
            url_ += "clientProfileId=" + encodeURIComponent("" + clientProfileId) + "&";
        if (serverLocation !== undefined && serverLocation !== null)
            url_ += "serverLocation=" + encodeURIComponent("" + serverLocation) + "&";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnect(_response);
        });
    }

    protected processConnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    diagnose(clientProfileId?: string | null | undefined, serverLocation?: string | null | undefined, planId?: ConnectPlanId | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/diagnose?";
        if (clientProfileId !== undefined && clientProfileId !== null)
            url_ += "clientProfileId=" + encodeURIComponent("" + clientProfileId) + "&";
        if (serverLocation !== undefined && serverLocation !== null)
            url_ += "serverLocation=" + encodeURIComponent("" + serverLocation) + "&";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDiagnose(_response);
        });
    }

    protected processDiagnose(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    disconnect( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/disconnect";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDisconnect(_response);
        });
    }

    protected processDisconnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    clearLastError( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/clear-last-error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearLastError(_response);
        });
    }

    protected processClearLastError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    extendByRewardedAd( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/extend-by-rewarded-ad";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExtendByRewardedAd(_response);
        });
    }

    protected processExtendByRewardedAd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    setUserSettings(userSettings: UserSettings, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/user-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userSettings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetUserSettings(_response);
        });
    }

    protected processSetUserSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    log( cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/app/log.txt";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLog(_response);
        });
    }

    protected processLog(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    getInstalledApps( cancelToken?: CancelToken): Promise<DeviceAppInfo[]> {
        let url_ = this.baseUrl + "/api/app/installed-apps";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInstalledApps(_response);
        });
    }

    protected processGetInstalledApps(response: AxiosResponse): Promise<DeviceAppInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceAppInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceAppInfo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceAppInfo[]>(null as any);
    }

    versionCheck( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/version-check";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVersionCheck(_response);
        });
    }

    protected processVersionCheck(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    versionCheckPostpone( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/version-check-postpone";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVersionCheckPostpone(_response);
        });
    }

    protected processVersionCheckPostpone(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    openAlwaysOnPage( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/settings/open-always-on-page";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOpenAlwaysOnPage(_response);
        });
    }

    protected processOpenAlwaysOnPage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    requestQuickLaunch( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/settings/request-quick-launch";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestQuickLaunch(_response);
        });
    }

    protected processRequestQuickLaunch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    requestNotification( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/settings/request-notification";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestNotification(_response);
        });
    }

    protected processRequestNotification(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BillingClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getSubscriptionPlans( cancelToken?: CancelToken): Promise<SubscriptionPlan[]> {
        let url_ = this.baseUrl + "/api/billing/subscription-plans";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSubscriptionPlans(_response);
        });
    }

    protected processGetSubscriptionPlans(response: AxiosResponse): Promise<SubscriptionPlan[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscriptionPlan.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SubscriptionPlan[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubscriptionPlan[]>(null as any);
    }

    purchase(planId: string, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/billing/purchase?";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined and cannot be null.");
        else
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPurchase(_response);
        });
    }

    protected processPurchase(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class ClientProfileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    addByAccessKey(accessKey: string, cancelToken?: CancelToken): Promise<ClientProfileInfo> {
        let url_ = this.baseUrl + "/api/client-profiles/access-keys?";
        if (accessKey === undefined || accessKey === null)
            throw new Error("The parameter 'accessKey' must be defined and cannot be null.");
        else
            url_ += "accessKey=" + encodeURIComponent("" + accessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddByAccessKey(_response);
        });
    }

    protected processAddByAccessKey(response: AxiosResponse): Promise<ClientProfileInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientProfileInfo.fromJS(resultData200);
            return Promise.resolve<ClientProfileInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfileInfo>(null as any);
    }

    get(clientProfileId: string, cancelToken?: CancelToken): Promise<ClientProfileInfo> {
        let url_ = this.baseUrl + "/api/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ClientProfileInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientProfileInfo.fromJS(resultData200);
            return Promise.resolve<ClientProfileInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfileInfo>(null as any);
    }

    update(clientProfileId: string, updateParams: ClientProfileUpdateParams, cancelToken?: CancelToken): Promise<ClientProfileInfo> {
        let url_ = this.baseUrl + "/api/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<ClientProfileInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientProfileInfo.fromJS(resultData200);
            return Promise.resolve<ClientProfileInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfileInfo>(null as any);
    }

    delete(clientProfileId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AppAccount implements IAppAccount {
    userId!: string;
    name?: string | null;
    email?: string | null;
    subscriptionId?: string | null;
    providerPlanId?: string | null;
    createdTime?: Date | null;
    expirationTime?: Date | null;
    priceAmount?: number | null;
    priceCurrency?: string | null;
    isAutoRenew?: boolean | null;
    providerSubscriptionId?: string | null;

    constructor(data?: IAppAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.subscriptionId = _data["subscriptionId"] !== undefined ? _data["subscriptionId"] : <any>null;
            this.providerPlanId = _data["providerPlanId"] !== undefined ? _data["providerPlanId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.priceAmount = _data["priceAmount"] !== undefined ? _data["priceAmount"] : <any>null;
            this.priceCurrency = _data["priceCurrency"] !== undefined ? _data["priceCurrency"] : <any>null;
            this.isAutoRenew = _data["isAutoRenew"] !== undefined ? _data["isAutoRenew"] : <any>null;
            this.providerSubscriptionId = _data["providerSubscriptionId"] !== undefined ? _data["providerSubscriptionId"] : <any>null;
        }
    }

    static fromJS(data: any): AppAccount {
        data = typeof data === 'object' ? data : {};
        let result = new AppAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["subscriptionId"] = this.subscriptionId !== undefined ? this.subscriptionId : <any>null;
        data["providerPlanId"] = this.providerPlanId !== undefined ? this.providerPlanId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["priceAmount"] = this.priceAmount !== undefined ? this.priceAmount : <any>null;
        data["priceCurrency"] = this.priceCurrency !== undefined ? this.priceCurrency : <any>null;
        data["isAutoRenew"] = this.isAutoRenew !== undefined ? this.isAutoRenew : <any>null;
        data["providerSubscriptionId"] = this.providerSubscriptionId !== undefined ? this.providerSubscriptionId : <any>null;
        return data;
    }
}

export interface IAppAccount {
    userId: string;
    name?: string | null;
    email?: string | null;
    subscriptionId?: string | null;
    providerPlanId?: string | null;
    createdTime?: Date | null;
    expirationTime?: Date | null;
    priceAmount?: number | null;
    priceCurrency?: string | null;
    isAutoRenew?: boolean | null;
    providerSubscriptionId?: string | null;
}

export class AppData implements IAppData {
    features!: AppFeatures;
    settings!: AppSettings;
    state!: AppState;
    clientProfileInfos!: ClientProfileInfo[];
    availableCultureInfos!: UiCultureInfo[];

    constructor(data?: IAppData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.features = new AppFeatures();
            this.settings = new AppSettings();
            this.state = new AppState();
            this.clientProfileInfos = [];
            this.availableCultureInfos = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.features = _data["features"] ? AppFeatures.fromJS(_data["features"]) : new AppFeatures();
            this.settings = _data["settings"] ? AppSettings.fromJS(_data["settings"]) : new AppSettings();
            this.state = _data["state"] ? AppState.fromJS(_data["state"]) : new AppState();
            if (Array.isArray(_data["clientProfileInfos"])) {
                this.clientProfileInfos = [] as any;
                for (let item of _data["clientProfileInfos"])
                    this.clientProfileInfos!.push(ClientProfileInfo.fromJS(item));
            }
            else {
                this.clientProfileInfos = <any>null;
            }
            if (Array.isArray(_data["availableCultureInfos"])) {
                this.availableCultureInfos = [] as any;
                for (let item of _data["availableCultureInfos"])
                    this.availableCultureInfos!.push(UiCultureInfo.fromJS(item));
            }
            else {
                this.availableCultureInfos = <any>null;
            }
        }
    }

    static fromJS(data: any): AppData {
        data = typeof data === 'object' ? data : {};
        let result = new AppData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["features"] = this.features ? this.features.toJSON() : <any>null;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>null;
        data["state"] = this.state ? this.state.toJSON() : <any>null;
        if (Array.isArray(this.clientProfileInfos)) {
            data["clientProfileInfos"] = [];
            for (let item of this.clientProfileInfos)
                data["clientProfileInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.availableCultureInfos)) {
            data["availableCultureInfos"] = [];
            for (let item of this.availableCultureInfos)
                data["availableCultureInfos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppData {
    features: AppFeatures;
    settings: AppSettings;
    state: AppState;
    clientProfileInfos: ClientProfileInfo[];
    availableCultureInfos: UiCultureInfo[];
}

export class AppFeatures implements IAppFeatures {
    appId!: string;
    version!: string;
    isExcludeAppsSupported!: boolean;
    isIncludeAppsSupported!: boolean;
    updateInfoUrl?: string | null;
    uiName?: string | null;
    isPremiumFlagSupported!: boolean;
    isAddAccessKeySupported!: boolean;
    builtInClientProfileId?: string | null;
    isAccountSupported!: boolean;
    isBillingSupported!: boolean;
    isQuickLaunchSupported!: boolean;
    isNotificationSupported!: boolean;
    isAlwaysOnSupported!: boolean;
    gaMeasurementId?: string | null;
    clientId!: string;
    isDebugMode!: boolean;
    debugCommands!: string[];

    constructor(data?: IAppFeatures) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.debugCommands = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"] !== undefined ? _data["appId"] : <any>null;
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.isExcludeAppsSupported = _data["isExcludeAppsSupported"] !== undefined ? _data["isExcludeAppsSupported"] : <any>null;
            this.isIncludeAppsSupported = _data["isIncludeAppsSupported"] !== undefined ? _data["isIncludeAppsSupported"] : <any>null;
            this.updateInfoUrl = _data["updateInfoUrl"] !== undefined ? _data["updateInfoUrl"] : <any>null;
            this.uiName = _data["uiName"] !== undefined ? _data["uiName"] : <any>null;
            this.isPremiumFlagSupported = _data["isPremiumFlagSupported"] !== undefined ? _data["isPremiumFlagSupported"] : <any>null;
            this.isAddAccessKeySupported = _data["isAddAccessKeySupported"] !== undefined ? _data["isAddAccessKeySupported"] : <any>null;
            this.builtInClientProfileId = _data["builtInClientProfileId"] !== undefined ? _data["builtInClientProfileId"] : <any>null;
            this.isAccountSupported = _data["isAccountSupported"] !== undefined ? _data["isAccountSupported"] : <any>null;
            this.isBillingSupported = _data["isBillingSupported"] !== undefined ? _data["isBillingSupported"] : <any>null;
            this.isQuickLaunchSupported = _data["isQuickLaunchSupported"] !== undefined ? _data["isQuickLaunchSupported"] : <any>null;
            this.isNotificationSupported = _data["isNotificationSupported"] !== undefined ? _data["isNotificationSupported"] : <any>null;
            this.isAlwaysOnSupported = _data["isAlwaysOnSupported"] !== undefined ? _data["isAlwaysOnSupported"] : <any>null;
            this.gaMeasurementId = _data["gaMeasurementId"] !== undefined ? _data["gaMeasurementId"] : <any>null;
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
            this.isDebugMode = _data["isDebugMode"] !== undefined ? _data["isDebugMode"] : <any>null;
            if (Array.isArray(_data["debugCommands"])) {
                this.debugCommands = [] as any;
                for (let item of _data["debugCommands"])
                    this.debugCommands!.push(item);
            }
            else {
                this.debugCommands = <any>null;
            }
        }
    }

    static fromJS(data: any): AppFeatures {
        data = typeof data === 'object' ? data : {};
        let result = new AppFeatures();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId !== undefined ? this.appId : <any>null;
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["isExcludeAppsSupported"] = this.isExcludeAppsSupported !== undefined ? this.isExcludeAppsSupported : <any>null;
        data["isIncludeAppsSupported"] = this.isIncludeAppsSupported !== undefined ? this.isIncludeAppsSupported : <any>null;
        data["updateInfoUrl"] = this.updateInfoUrl !== undefined ? this.updateInfoUrl : <any>null;
        data["uiName"] = this.uiName !== undefined ? this.uiName : <any>null;
        data["isPremiumFlagSupported"] = this.isPremiumFlagSupported !== undefined ? this.isPremiumFlagSupported : <any>null;
        data["isAddAccessKeySupported"] = this.isAddAccessKeySupported !== undefined ? this.isAddAccessKeySupported : <any>null;
        data["builtInClientProfileId"] = this.builtInClientProfileId !== undefined ? this.builtInClientProfileId : <any>null;
        data["isAccountSupported"] = this.isAccountSupported !== undefined ? this.isAccountSupported : <any>null;
        data["isBillingSupported"] = this.isBillingSupported !== undefined ? this.isBillingSupported : <any>null;
        data["isQuickLaunchSupported"] = this.isQuickLaunchSupported !== undefined ? this.isQuickLaunchSupported : <any>null;
        data["isNotificationSupported"] = this.isNotificationSupported !== undefined ? this.isNotificationSupported : <any>null;
        data["isAlwaysOnSupported"] = this.isAlwaysOnSupported !== undefined ? this.isAlwaysOnSupported : <any>null;
        data["gaMeasurementId"] = this.gaMeasurementId !== undefined ? this.gaMeasurementId : <any>null;
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        data["isDebugMode"] = this.isDebugMode !== undefined ? this.isDebugMode : <any>null;
        if (Array.isArray(this.debugCommands)) {
            data["debugCommands"] = [];
            for (let item of this.debugCommands)
                data["debugCommands"].push(item);
        }
        return data;
    }
}

export interface IAppFeatures {
    appId: string;
    version: string;
    isExcludeAppsSupported: boolean;
    isIncludeAppsSupported: boolean;
    updateInfoUrl?: string | null;
    uiName?: string | null;
    isPremiumFlagSupported: boolean;
    isAddAccessKeySupported: boolean;
    builtInClientProfileId?: string | null;
    isAccountSupported: boolean;
    isBillingSupported: boolean;
    isQuickLaunchSupported: boolean;
    isNotificationSupported: boolean;
    isAlwaysOnSupported: boolean;
    gaMeasurementId?: string | null;
    clientId: string;
    isDebugMode: boolean;
    debugCommands: string[];
}

export class AppSettings implements IAppSettings {
    version!: number;
    isQuickLaunchEnabled?: boolean | null;
    isNotificationEnabled?: boolean | null;
    configTime!: Date;
    userSettings!: UserSettings;
    clientId!: string;

    constructor(data?: IAppSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userSettings = new UserSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.isQuickLaunchEnabled = _data["isQuickLaunchEnabled"] !== undefined ? _data["isQuickLaunchEnabled"] : <any>null;
            this.isNotificationEnabled = _data["isNotificationEnabled"] !== undefined ? _data["isNotificationEnabled"] : <any>null;
            this.configTime = _data["configTime"] ? new Date(_data["configTime"].toString()) : <any>null;
            this.userSettings = _data["userSettings"] ? UserSettings.fromJS(_data["userSettings"]) : new UserSettings();
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
        }
    }

    static fromJS(data: any): AppSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["isQuickLaunchEnabled"] = this.isQuickLaunchEnabled !== undefined ? this.isQuickLaunchEnabled : <any>null;
        data["isNotificationEnabled"] = this.isNotificationEnabled !== undefined ? this.isNotificationEnabled : <any>null;
        data["configTime"] = this.configTime ? this.configTime.toISOString() : <any>null;
        data["userSettings"] = this.userSettings ? this.userSettings.toJSON() : <any>null;
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        return data;
    }
}

export interface IAppSettings {
    version: number;
    isQuickLaunchEnabled?: boolean | null;
    isNotificationEnabled?: boolean | null;
    configTime: Date;
    userSettings: UserSettings;
    clientId: string;
}

export class UserSettings implements IUserSettings {
    isLicenseAccepted!: boolean;
    cultureCode?: string | null;
    clientProfileId?: string | null;
    maxDatagramChannelCount!: number;
    tunnelClientCountry!: boolean;
    appFilters!: string[];
    appFiltersMode!: FilterMode;
    useUdpChannel!: boolean;
    dropUdp!: boolean;
    dropQuic!: boolean;
    allowAnonymousTracker!: boolean;
    dnsServers?: string[] | null;
    domainFilter!: DomainFilter;
    debugData1?: string | null;
    debugData2?: string | null;
    logAnonymous!: boolean;
    includeLocalNetwork!: boolean;
    includeIpRanges!: string[];
    excludeIpRanges!: string[];
    packetCaptureIncludeIpRanges!: string[];
    packetCaptureExcludeIpRanges!: string[];

    constructor(data?: IUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.appFilters = [];
            this.domainFilter = new DomainFilter();
            this.includeIpRanges = [];
            this.excludeIpRanges = [];
            this.packetCaptureIncludeIpRanges = [];
            this.packetCaptureExcludeIpRanges = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLicenseAccepted = _data["isLicenseAccepted"] !== undefined ? _data["isLicenseAccepted"] : <any>null;
            this.cultureCode = _data["cultureCode"] !== undefined ? _data["cultureCode"] : <any>null;
            this.clientProfileId = _data["clientProfileId"] !== undefined ? _data["clientProfileId"] : <any>null;
            this.maxDatagramChannelCount = _data["maxDatagramChannelCount"] !== undefined ? _data["maxDatagramChannelCount"] : <any>null;
            this.tunnelClientCountry = _data["tunnelClientCountry"] !== undefined ? _data["tunnelClientCountry"] : <any>null;
            if (Array.isArray(_data["appFilters"])) {
                this.appFilters = [] as any;
                for (let item of _data["appFilters"])
                    this.appFilters!.push(item);
            }
            else {
                this.appFilters = <any>null;
            }
            this.appFiltersMode = _data["appFiltersMode"] !== undefined ? _data["appFiltersMode"] : <any>null;
            this.useUdpChannel = _data["useUdpChannel"] !== undefined ? _data["useUdpChannel"] : <any>null;
            this.dropUdp = _data["dropUdp"] !== undefined ? _data["dropUdp"] : <any>null;
            this.dropQuic = _data["dropQuic"] !== undefined ? _data["dropQuic"] : <any>null;
            this.allowAnonymousTracker = _data["allowAnonymousTracker"] !== undefined ? _data["allowAnonymousTracker"] : <any>null;
            if (Array.isArray(_data["dnsServers"])) {
                this.dnsServers = [] as any;
                for (let item of _data["dnsServers"])
                    this.dnsServers!.push(item);
            }
            else {
                this.dnsServers = <any>null;
            }
            this.domainFilter = _data["domainFilter"] ? DomainFilter.fromJS(_data["domainFilter"]) : new DomainFilter();
            this.debugData1 = _data["debugData1"] !== undefined ? _data["debugData1"] : <any>null;
            this.debugData2 = _data["debugData2"] !== undefined ? _data["debugData2"] : <any>null;
            this.logAnonymous = _data["logAnonymous"] !== undefined ? _data["logAnonymous"] : <any>null;
            this.includeLocalNetwork = _data["includeLocalNetwork"] !== undefined ? _data["includeLocalNetwork"] : <any>null;
            if (Array.isArray(_data["includeIpRanges"])) {
                this.includeIpRanges = [] as any;
                for (let item of _data["includeIpRanges"])
                    this.includeIpRanges!.push(item);
            }
            else {
                this.includeIpRanges = <any>null;
            }
            if (Array.isArray(_data["excludeIpRanges"])) {
                this.excludeIpRanges = [] as any;
                for (let item of _data["excludeIpRanges"])
                    this.excludeIpRanges!.push(item);
            }
            else {
                this.excludeIpRanges = <any>null;
            }
            if (Array.isArray(_data["packetCaptureIncludeIpRanges"])) {
                this.packetCaptureIncludeIpRanges = [] as any;
                for (let item of _data["packetCaptureIncludeIpRanges"])
                    this.packetCaptureIncludeIpRanges!.push(item);
            }
            else {
                this.packetCaptureIncludeIpRanges = <any>null;
            }
            if (Array.isArray(_data["packetCaptureExcludeIpRanges"])) {
                this.packetCaptureExcludeIpRanges = [] as any;
                for (let item of _data["packetCaptureExcludeIpRanges"])
                    this.packetCaptureExcludeIpRanges!.push(item);
            }
            else {
                this.packetCaptureExcludeIpRanges = <any>null;
            }
        }
    }

    static fromJS(data: any): UserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLicenseAccepted"] = this.isLicenseAccepted !== undefined ? this.isLicenseAccepted : <any>null;
        data["cultureCode"] = this.cultureCode !== undefined ? this.cultureCode : <any>null;
        data["clientProfileId"] = this.clientProfileId !== undefined ? this.clientProfileId : <any>null;
        data["maxDatagramChannelCount"] = this.maxDatagramChannelCount !== undefined ? this.maxDatagramChannelCount : <any>null;
        data["tunnelClientCountry"] = this.tunnelClientCountry !== undefined ? this.tunnelClientCountry : <any>null;
        if (Array.isArray(this.appFilters)) {
            data["appFilters"] = [];
            for (let item of this.appFilters)
                data["appFilters"].push(item);
        }
        data["appFiltersMode"] = this.appFiltersMode !== undefined ? this.appFiltersMode : <any>null;
        data["useUdpChannel"] = this.useUdpChannel !== undefined ? this.useUdpChannel : <any>null;
        data["dropUdp"] = this.dropUdp !== undefined ? this.dropUdp : <any>null;
        data["dropQuic"] = this.dropQuic !== undefined ? this.dropQuic : <any>null;
        data["allowAnonymousTracker"] = this.allowAnonymousTracker !== undefined ? this.allowAnonymousTracker : <any>null;
        if (Array.isArray(this.dnsServers)) {
            data["dnsServers"] = [];
            for (let item of this.dnsServers)
                data["dnsServers"].push(item);
        }
        data["domainFilter"] = this.domainFilter ? this.domainFilter.toJSON() : <any>null;
        data["debugData1"] = this.debugData1 !== undefined ? this.debugData1 : <any>null;
        data["debugData2"] = this.debugData2 !== undefined ? this.debugData2 : <any>null;
        data["logAnonymous"] = this.logAnonymous !== undefined ? this.logAnonymous : <any>null;
        data["includeLocalNetwork"] = this.includeLocalNetwork !== undefined ? this.includeLocalNetwork : <any>null;
        if (Array.isArray(this.includeIpRanges)) {
            data["includeIpRanges"] = [];
            for (let item of this.includeIpRanges)
                data["includeIpRanges"].push(item);
        }
        if (Array.isArray(this.excludeIpRanges)) {
            data["excludeIpRanges"] = [];
            for (let item of this.excludeIpRanges)
                data["excludeIpRanges"].push(item);
        }
        if (Array.isArray(this.packetCaptureIncludeIpRanges)) {
            data["packetCaptureIncludeIpRanges"] = [];
            for (let item of this.packetCaptureIncludeIpRanges)
                data["packetCaptureIncludeIpRanges"].push(item);
        }
        if (Array.isArray(this.packetCaptureExcludeIpRanges)) {
            data["packetCaptureExcludeIpRanges"] = [];
            for (let item of this.packetCaptureExcludeIpRanges)
                data["packetCaptureExcludeIpRanges"].push(item);
        }
        return data;
    }
}

export interface IUserSettings {
    isLicenseAccepted: boolean;
    cultureCode?: string | null;
    clientProfileId?: string | null;
    maxDatagramChannelCount: number;
    tunnelClientCountry: boolean;
    appFilters: string[];
    appFiltersMode: FilterMode;
    useUdpChannel: boolean;
    dropUdp: boolean;
    dropQuic: boolean;
    allowAnonymousTracker: boolean;
    dnsServers?: string[] | null;
    domainFilter: DomainFilter;
    debugData1?: string | null;
    debugData2?: string | null;
    logAnonymous: boolean;
    includeLocalNetwork: boolean;
    includeIpRanges: string[];
    excludeIpRanges: string[];
    packetCaptureIncludeIpRanges: string[];
    packetCaptureExcludeIpRanges: string[];
}

export enum FilterMode {
    All = "All",
    Exclude = "Exclude",
    Include = "Include",
}

export class DomainFilter implements IDomainFilter {
    blocks!: string[];
    excludes!: string[];
    includes!: string[];

    constructor(data?: IDomainFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.blocks = [];
            this.excludes = [];
            this.includes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["blocks"])) {
                this.blocks = [] as any;
                for (let item of _data["blocks"])
                    this.blocks!.push(item);
            }
            else {
                this.blocks = <any>null;
            }
            if (Array.isArray(_data["excludes"])) {
                this.excludes = [] as any;
                for (let item of _data["excludes"])
                    this.excludes!.push(item);
            }
            else {
                this.excludes = <any>null;
            }
            if (Array.isArray(_data["includes"])) {
                this.includes = [] as any;
                for (let item of _data["includes"])
                    this.includes!.push(item);
            }
            else {
                this.includes = <any>null;
            }
        }
    }

    static fromJS(data: any): DomainFilter {
        data = typeof data === 'object' ? data : {};
        let result = new DomainFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.blocks)) {
            data["blocks"] = [];
            for (let item of this.blocks)
                data["blocks"].push(item);
        }
        if (Array.isArray(this.excludes)) {
            data["excludes"] = [];
            for (let item of this.excludes)
                data["excludes"].push(item);
        }
        if (Array.isArray(this.includes)) {
            data["includes"] = [];
            for (let item of this.includes)
                data["includes"].push(item);
        }
        return data;
    }
}

export interface IDomainFilter {
    blocks: string[];
    excludes: string[];
    includes: string[];
}

export class AppState implements IAppState {
    configTime!: Date;
    connectRequestTime?: Date | null;
    connectionState!: AppConnectionState;
    lastError?: ApiError | null;
    clientProfile?: ClientProfileBaseInfo | null;
    serverLocationInfo?: ServerLocationInfo | null;
    isIdle!: boolean;
    promptForLog!: boolean;
    logExists!: boolean;
    hasDiagnoseRequested!: boolean;
    hasDisconnectedByUser!: boolean;
    hasProblemDetected!: boolean;
    sessionStatus?: SessionStatus | null;
    speed!: Traffic;
    sessionTraffic!: Traffic;
    accountTraffic!: Traffic;
    clientCountryCode?: string | null;
    clientCountryName?: string | null;
    isWaitingForAd!: boolean;
    versionStatus!: VersionStatus;
    lastPublishInfo?: PublishInfo | null;
    isUdpChannelSupported?: boolean | null;
    canDisconnect!: boolean;
    canConnect!: boolean;
    canDiagnose!: boolean;
    currentUiCultureInfo!: UiCultureInfo;
    systemUiCultureInfo!: UiCultureInfo;
    purchaseState?: BillingPurchaseState | null;
    tcpTunnelledCount?: number | null;
    tcpPassthruCount?: number | null;

    constructor(data?: IAppState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.speed = new Traffic();
            this.sessionTraffic = new Traffic();
            this.accountTraffic = new Traffic();
            this.currentUiCultureInfo = new UiCultureInfo();
            this.systemUiCultureInfo = new UiCultureInfo();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configTime = _data["configTime"] ? new Date(_data["configTime"].toString()) : <any>null;
            this.connectRequestTime = _data["connectRequestTime"] ? new Date(_data["connectRequestTime"].toString()) : <any>null;
            this.connectionState = _data["connectionState"] !== undefined ? _data["connectionState"] : <any>null;
            this.lastError = _data["lastError"] ? ApiError.fromJS(_data["lastError"]) : <any>null;
            this.clientProfile = _data["clientProfile"] ? ClientProfileBaseInfo.fromJS(_data["clientProfile"]) : <any>null;
            this.serverLocationInfo = _data["serverLocationInfo"] ? ServerLocationInfo.fromJS(_data["serverLocationInfo"]) : <any>null;
            this.isIdle = _data["isIdle"] !== undefined ? _data["isIdle"] : <any>null;
            this.promptForLog = _data["promptForLog"] !== undefined ? _data["promptForLog"] : <any>null;
            this.logExists = _data["logExists"] !== undefined ? _data["logExists"] : <any>null;
            this.hasDiagnoseRequested = _data["hasDiagnoseRequested"] !== undefined ? _data["hasDiagnoseRequested"] : <any>null;
            this.hasDisconnectedByUser = _data["hasDisconnectedByUser"] !== undefined ? _data["hasDisconnectedByUser"] : <any>null;
            this.hasProblemDetected = _data["hasProblemDetected"] !== undefined ? _data["hasProblemDetected"] : <any>null;
            this.sessionStatus = _data["sessionStatus"] ? SessionStatus.fromJS(_data["sessionStatus"]) : <any>null;
            this.speed = _data["speed"] ? Traffic.fromJS(_data["speed"]) : new Traffic();
            this.sessionTraffic = _data["sessionTraffic"] ? Traffic.fromJS(_data["sessionTraffic"]) : new Traffic();
            this.accountTraffic = _data["accountTraffic"] ? Traffic.fromJS(_data["accountTraffic"]) : new Traffic();
            this.clientCountryCode = _data["clientCountryCode"] !== undefined ? _data["clientCountryCode"] : <any>null;
            this.clientCountryName = _data["clientCountryName"] !== undefined ? _data["clientCountryName"] : <any>null;
            this.isWaitingForAd = _data["isWaitingForAd"] !== undefined ? _data["isWaitingForAd"] : <any>null;
            this.versionStatus = _data["versionStatus"] !== undefined ? _data["versionStatus"] : <any>null;
            this.lastPublishInfo = _data["lastPublishInfo"] ? PublishInfo.fromJS(_data["lastPublishInfo"]) : <any>null;
            this.isUdpChannelSupported = _data["isUdpChannelSupported"] !== undefined ? _data["isUdpChannelSupported"] : <any>null;
            this.canDisconnect = _data["canDisconnect"] !== undefined ? _data["canDisconnect"] : <any>null;
            this.canConnect = _data["canConnect"] !== undefined ? _data["canConnect"] : <any>null;
            this.canDiagnose = _data["canDiagnose"] !== undefined ? _data["canDiagnose"] : <any>null;
            this.currentUiCultureInfo = _data["currentUiCultureInfo"] ? UiCultureInfo.fromJS(_data["currentUiCultureInfo"]) : new UiCultureInfo();
            this.systemUiCultureInfo = _data["systemUiCultureInfo"] ? UiCultureInfo.fromJS(_data["systemUiCultureInfo"]) : new UiCultureInfo();
            this.purchaseState = _data["purchaseState"] !== undefined ? _data["purchaseState"] : <any>null;
            this.tcpTunnelledCount = _data["tcpTunnelledCount"] !== undefined ? _data["tcpTunnelledCount"] : <any>null;
            this.tcpPassthruCount = _data["tcpPassthruCount"] !== undefined ? _data["tcpPassthruCount"] : <any>null;
        }
    }

    static fromJS(data: any): AppState {
        data = typeof data === 'object' ? data : {};
        let result = new AppState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configTime"] = this.configTime ? this.configTime.toISOString() : <any>null;
        data["connectRequestTime"] = this.connectRequestTime ? this.connectRequestTime.toISOString() : <any>null;
        data["connectionState"] = this.connectionState !== undefined ? this.connectionState : <any>null;
        data["lastError"] = this.lastError ? this.lastError.toJSON() : <any>null;
        data["clientProfile"] = this.clientProfile ? this.clientProfile.toJSON() : <any>null;
        data["serverLocationInfo"] = this.serverLocationInfo ? this.serverLocationInfo.toJSON() : <any>null;
        data["isIdle"] = this.isIdle !== undefined ? this.isIdle : <any>null;
        data["promptForLog"] = this.promptForLog !== undefined ? this.promptForLog : <any>null;
        data["logExists"] = this.logExists !== undefined ? this.logExists : <any>null;
        data["hasDiagnoseRequested"] = this.hasDiagnoseRequested !== undefined ? this.hasDiagnoseRequested : <any>null;
        data["hasDisconnectedByUser"] = this.hasDisconnectedByUser !== undefined ? this.hasDisconnectedByUser : <any>null;
        data["hasProblemDetected"] = this.hasProblemDetected !== undefined ? this.hasProblemDetected : <any>null;
        data["sessionStatus"] = this.sessionStatus ? this.sessionStatus.toJSON() : <any>null;
        data["speed"] = this.speed ? this.speed.toJSON() : <any>null;
        data["sessionTraffic"] = this.sessionTraffic ? this.sessionTraffic.toJSON() : <any>null;
        data["accountTraffic"] = this.accountTraffic ? this.accountTraffic.toJSON() : <any>null;
        data["clientCountryCode"] = this.clientCountryCode !== undefined ? this.clientCountryCode : <any>null;
        data["clientCountryName"] = this.clientCountryName !== undefined ? this.clientCountryName : <any>null;
        data["isWaitingForAd"] = this.isWaitingForAd !== undefined ? this.isWaitingForAd : <any>null;
        data["versionStatus"] = this.versionStatus !== undefined ? this.versionStatus : <any>null;
        data["lastPublishInfo"] = this.lastPublishInfo ? this.lastPublishInfo.toJSON() : <any>null;
        data["isUdpChannelSupported"] = this.isUdpChannelSupported !== undefined ? this.isUdpChannelSupported : <any>null;
        data["canDisconnect"] = this.canDisconnect !== undefined ? this.canDisconnect : <any>null;
        data["canConnect"] = this.canConnect !== undefined ? this.canConnect : <any>null;
        data["canDiagnose"] = this.canDiagnose !== undefined ? this.canDiagnose : <any>null;
        data["currentUiCultureInfo"] = this.currentUiCultureInfo ? this.currentUiCultureInfo.toJSON() : <any>null;
        data["systemUiCultureInfo"] = this.systemUiCultureInfo ? this.systemUiCultureInfo.toJSON() : <any>null;
        data["purchaseState"] = this.purchaseState !== undefined ? this.purchaseState : <any>null;
        data["tcpTunnelledCount"] = this.tcpTunnelledCount !== undefined ? this.tcpTunnelledCount : <any>null;
        data["tcpPassthruCount"] = this.tcpPassthruCount !== undefined ? this.tcpPassthruCount : <any>null;
        return data;
    }
}

export interface IAppState {
    configTime: Date;
    connectRequestTime?: Date | null;
    connectionState: AppConnectionState;
    lastError?: ApiError | null;
    clientProfile?: ClientProfileBaseInfo | null;
    serverLocationInfo?: ServerLocationInfo | null;
    isIdle: boolean;
    promptForLog: boolean;
    logExists: boolean;
    hasDiagnoseRequested: boolean;
    hasDisconnectedByUser: boolean;
    hasProblemDetected: boolean;
    sessionStatus?: SessionStatus | null;
    speed: Traffic;
    sessionTraffic: Traffic;
    accountTraffic: Traffic;
    clientCountryCode?: string | null;
    clientCountryName?: string | null;
    isWaitingForAd: boolean;
    versionStatus: VersionStatus;
    lastPublishInfo?: PublishInfo | null;
    isUdpChannelSupported?: boolean | null;
    canDisconnect: boolean;
    canConnect: boolean;
    canDiagnose: boolean;
    currentUiCultureInfo: UiCultureInfo;
    systemUiCultureInfo: UiCultureInfo;
    purchaseState?: BillingPurchaseState | null;
    tcpTunnelledCount?: number | null;
    tcpPassthruCount?: number | null;
}

export enum AppConnectionState {
    None = "None",
    Initializing = "Initializing",
    Waiting = "Waiting",
    Diagnosing = "Diagnosing",
    Connecting = "Connecting",
    Connected = "Connected",
    Disconnecting = "Disconnecting",
}

export class ApiError implements IApiError {
    typeName!: string;
    typeFullName?: string | null;
    message!: string;
    data!: { [key: string]: string; };
    innerMessage?: string | null;

    constructor(data?: IApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"] !== undefined ? _data["typeName"] : <any>null;
            this.typeFullName = _data["typeFullName"] !== undefined ? _data["typeFullName"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key] !== undefined ? _data["data"][key] : <any>null;
                }
            }
            else {
                this.data = <any>null;
            }
            this.innerMessage = _data["innerMessage"] !== undefined ? _data["innerMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ApiError {
        data = typeof data === 'object' ? data : {};
        let result = new ApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName !== undefined ? this.typeName : <any>null;
        data["typeFullName"] = this.typeFullName !== undefined ? this.typeFullName : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = this.data[key] !== undefined ? this.data[key] : <any>null;
            }
        }
        data["innerMessage"] = this.innerMessage !== undefined ? this.innerMessage : <any>null;
        return data;
    }
}

export interface IApiError {
    typeName: string;
    typeFullName?: string | null;
    message: string;
    data: { [key: string]: string; };
    innerMessage?: string | null;
}

export class ClientProfileBaseInfo implements IClientProfileBaseInfo {
    clientProfileId!: string;
    clientProfileName!: string;
    supportId?: string | null;
    customData?: string | null;
    isPremiumLocationSelected!: boolean;
    isPremiumAccount!: boolean;
    selectedLocationInfo?: ClientServerLocationInfo | null;
    hasAccessCode!: boolean;

    constructor(data?: IClientProfileBaseInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileId = _data["clientProfileId"] !== undefined ? _data["clientProfileId"] : <any>null;
            this.clientProfileName = _data["clientProfileName"] !== undefined ? _data["clientProfileName"] : <any>null;
            this.supportId = _data["supportId"] !== undefined ? _data["supportId"] : <any>null;
            this.customData = _data["customData"] !== undefined ? _data["customData"] : <any>null;
            this.isPremiumLocationSelected = _data["isPremiumLocationSelected"] !== undefined ? _data["isPremiumLocationSelected"] : <any>null;
            this.isPremiumAccount = _data["isPremiumAccount"] !== undefined ? _data["isPremiumAccount"] : <any>null;
            this.selectedLocationInfo = _data["selectedLocationInfo"] ? ClientServerLocationInfo.fromJS(_data["selectedLocationInfo"]) : <any>null;
            this.hasAccessCode = _data["hasAccessCode"] !== undefined ? _data["hasAccessCode"] : <any>null;
        }
    }

    static fromJS(data: any): ClientProfileBaseInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileBaseInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileId"] = this.clientProfileId !== undefined ? this.clientProfileId : <any>null;
        data["clientProfileName"] = this.clientProfileName !== undefined ? this.clientProfileName : <any>null;
        data["supportId"] = this.supportId !== undefined ? this.supportId : <any>null;
        data["customData"] = this.customData !== undefined ? this.customData : <any>null;
        data["isPremiumLocationSelected"] = this.isPremiumLocationSelected !== undefined ? this.isPremiumLocationSelected : <any>null;
        data["isPremiumAccount"] = this.isPremiumAccount !== undefined ? this.isPremiumAccount : <any>null;
        data["selectedLocationInfo"] = this.selectedLocationInfo ? this.selectedLocationInfo.toJSON() : <any>null;
        data["hasAccessCode"] = this.hasAccessCode !== undefined ? this.hasAccessCode : <any>null;
        return data;
    }
}

export interface IClientProfileBaseInfo {
    clientProfileId: string;
    clientProfileName: string;
    supportId?: string | null;
    customData?: string | null;
    isPremiumLocationSelected: boolean;
    isPremiumAccount: boolean;
    selectedLocationInfo?: ClientServerLocationInfo | null;
    hasAccessCode: boolean;
}

export class ServerLocationInfo implements IServerLocationInfo {
    countryCode!: string;
    regionName!: string;
    tags?: string[] | null;
    serverLocation!: string;
    countryName!: string;
    isAuto!: boolean;

    constructor(data?: IServerLocationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"] !== undefined ? _data["countryCode"] : <any>null;
            this.regionName = _data["regionName"] !== undefined ? _data["regionName"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            this.serverLocation = _data["serverLocation"] !== undefined ? _data["serverLocation"] : <any>null;
            this.countryName = _data["countryName"] !== undefined ? _data["countryName"] : <any>null;
            this.isAuto = _data["isAuto"] !== undefined ? _data["isAuto"] : <any>null;
        }
    }

    static fromJS(data: any): ServerLocationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ServerLocationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode !== undefined ? this.countryCode : <any>null;
        data["regionName"] = this.regionName !== undefined ? this.regionName : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["serverLocation"] = this.serverLocation !== undefined ? this.serverLocation : <any>null;
        data["countryName"] = this.countryName !== undefined ? this.countryName : <any>null;
        data["isAuto"] = this.isAuto !== undefined ? this.isAuto : <any>null;
        return data;
    }
}

export interface IServerLocationInfo {
    countryCode: string;
    regionName: string;
    tags?: string[] | null;
    serverLocation: string;
    countryName: string;
    isAuto: boolean;
}

export class ClientServerLocationInfo extends ServerLocationInfo implements IClientServerLocationInfo {
    isNestedCountry!: boolean;
    isDefault!: boolean;
    options!: ServerLocationOptions;

    constructor(data?: IClientServerLocationInfo) {
        super(data);
        if (!data) {
            this.options = new ServerLocationOptions();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isNestedCountry = _data["isNestedCountry"] !== undefined ? _data["isNestedCountry"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.options = _data["options"] ? ServerLocationOptions.fromJS(_data["options"]) : new ServerLocationOptions();
        }
    }

    static override fromJS(data: any): ClientServerLocationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientServerLocationInfo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNestedCountry"] = this.isNestedCountry !== undefined ? this.isNestedCountry : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["options"] = this.options ? this.options.toJSON() : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IClientServerLocationInfo extends IServerLocationInfo {
    isNestedCountry: boolean;
    isDefault: boolean;
    options: ServerLocationOptions;
}

export class ServerLocationOptions implements IServerLocationOptions {
    normal?: number | null;
    premiumByTrial?: number | null;
    premiumByRewardedAd?: number | null;
    premiumByPurchase!: boolean;
    premiumByCode!: boolean;
    canGoPremium!: boolean;
    hasFree!: boolean;
    hasPremium!: boolean;
    hasUnblockable!: boolean;
    prompt!: boolean;

    constructor(data?: IServerLocationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.normal = _data["normal"] !== undefined ? _data["normal"] : <any>null;
            this.premiumByTrial = _data["premiumByTrial"] !== undefined ? _data["premiumByTrial"] : <any>null;
            this.premiumByRewardedAd = _data["premiumByRewardedAd"] !== undefined ? _data["premiumByRewardedAd"] : <any>null;
            this.premiumByPurchase = _data["premiumByPurchase"] !== undefined ? _data["premiumByPurchase"] : <any>null;
            this.premiumByCode = _data["premiumByCode"] !== undefined ? _data["premiumByCode"] : <any>null;
            this.canGoPremium = _data["canGoPremium"] !== undefined ? _data["canGoPremium"] : <any>null;
            this.hasFree = _data["hasFree"] !== undefined ? _data["hasFree"] : <any>null;
            this.hasPremium = _data["hasPremium"] !== undefined ? _data["hasPremium"] : <any>null;
            this.hasUnblockable = _data["hasUnblockable"] !== undefined ? _data["hasUnblockable"] : <any>null;
            this.prompt = _data["prompt"] !== undefined ? _data["prompt"] : <any>null;
        }
    }

    static fromJS(data: any): ServerLocationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ServerLocationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["normal"] = this.normal !== undefined ? this.normal : <any>null;
        data["premiumByTrial"] = this.premiumByTrial !== undefined ? this.premiumByTrial : <any>null;
        data["premiumByRewardedAd"] = this.premiumByRewardedAd !== undefined ? this.premiumByRewardedAd : <any>null;
        data["premiumByPurchase"] = this.premiumByPurchase !== undefined ? this.premiumByPurchase : <any>null;
        data["premiumByCode"] = this.premiumByCode !== undefined ? this.premiumByCode : <any>null;
        data["canGoPremium"] = this.canGoPremium !== undefined ? this.canGoPremium : <any>null;
        data["hasFree"] = this.hasFree !== undefined ? this.hasFree : <any>null;
        data["hasPremium"] = this.hasPremium !== undefined ? this.hasPremium : <any>null;
        data["hasUnblockable"] = this.hasUnblockable !== undefined ? this.hasUnblockable : <any>null;
        data["prompt"] = this.prompt !== undefined ? this.prompt : <any>null;
        return data;
    }
}

export interface IServerLocationOptions {
    normal?: number | null;
    premiumByTrial?: number | null;
    premiumByRewardedAd?: number | null;
    premiumByPurchase: boolean;
    premiumByCode: boolean;
    canGoPremium: boolean;
    hasFree: boolean;
    hasPremium: boolean;
    hasUnblockable: boolean;
    prompt: boolean;
}

export class SessionStatus implements ISessionStatus {
    errorCode!: SessionErrorCode;
    accessUsage?: AccessUsage | null;
    suppressedTo!: SessionSuppressType;
    suppressedBy!: SessionSuppressType;
    error?: ApiError | null;

    constructor(data?: ISessionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"] !== undefined ? _data["errorCode"] : <any>null;
            this.accessUsage = _data["accessUsage"] ? AccessUsage.fromJS(_data["accessUsage"]) : <any>null;
            this.suppressedTo = _data["suppressedTo"] !== undefined ? _data["suppressedTo"] : <any>null;
            this.suppressedBy = _data["suppressedBy"] !== undefined ? _data["suppressedBy"] : <any>null;
            this.error = _data["error"] ? ApiError.fromJS(_data["error"]) : <any>null;
        }
    }

    static fromJS(data: any): SessionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SessionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode !== undefined ? this.errorCode : <any>null;
        data["accessUsage"] = this.accessUsage ? this.accessUsage.toJSON() : <any>null;
        data["suppressedTo"] = this.suppressedTo !== undefined ? this.suppressedTo : <any>null;
        data["suppressedBy"] = this.suppressedBy !== undefined ? this.suppressedBy : <any>null;
        data["error"] = this.error ? this.error.toJSON() : <any>null;
        return data;
    }
}

export interface ISessionStatus {
    errorCode: SessionErrorCode;
    accessUsage?: AccessUsage | null;
    suppressedTo: SessionSuppressType;
    suppressedBy: SessionSuppressType;
    error?: ApiError | null;
}

export enum SessionErrorCode {
    Ok = "Ok",
    AccessError = "AccessError",
    PlanRejected = "PlanRejected",
    GeneralError = "GeneralError",
    SessionClosed = "SessionClosed",
    SessionSuppressedBy = "SessionSuppressedBy",
    SessionError = "SessionError",
    SessionExpired = "SessionExpired",
    AccessExpired = "AccessExpired",
    AccessCodeRejected = "AccessCodeRejected",
    AccessLocked = "AccessLocked",
    AccessTrafficOverflow = "AccessTrafficOverflow",
    NoServerAvailable = "NoServerAvailable",
    AdError = "AdError",
    RewardedAdRejected = "RewardedAdRejected",
    Maintenance = "Maintenance",
    RedirectHost = "RedirectHost",
    UnsupportedClient = "UnsupportedClient",
    UnsupportedServer = "UnsupportedServer",
}

export class AccessUsage implements IAccessUsage {
    canExtendByRewardedAd!: boolean;
    isPremium!: boolean;
    traffic!: Traffic;
    maxTraffic!: number;
    expirationTime?: Date | null;
    maxClientCount!: number;
    activeClientCount?: number | null;

    constructor(data?: IAccessUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.traffic = new Traffic();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canExtendByRewardedAd = _data["canExtendByRewardedAd"] !== undefined ? _data["canExtendByRewardedAd"] : <any>null;
            this.isPremium = _data["isPremium"] !== undefined ? _data["isPremium"] : <any>null;
            this.traffic = _data["traffic"] ? Traffic.fromJS(_data["traffic"]) : new Traffic();
            this.maxTraffic = _data["maxTraffic"] !== undefined ? _data["maxTraffic"] : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.maxClientCount = _data["maxClientCount"] !== undefined ? _data["maxClientCount"] : <any>null;
            this.activeClientCount = _data["activeClientCount"] !== undefined ? _data["activeClientCount"] : <any>null;
        }
    }

    static fromJS(data: any): AccessUsage {
        data = typeof data === 'object' ? data : {};
        let result = new AccessUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canExtendByRewardedAd"] = this.canExtendByRewardedAd !== undefined ? this.canExtendByRewardedAd : <any>null;
        data["isPremium"] = this.isPremium !== undefined ? this.isPremium : <any>null;
        data["traffic"] = this.traffic ? this.traffic.toJSON() : <any>null;
        data["maxTraffic"] = this.maxTraffic !== undefined ? this.maxTraffic : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["maxClientCount"] = this.maxClientCount !== undefined ? this.maxClientCount : <any>null;
        data["activeClientCount"] = this.activeClientCount !== undefined ? this.activeClientCount : <any>null;
        return data;
    }
}

export interface IAccessUsage {
    canExtendByRewardedAd: boolean;
    isPremium: boolean;
    traffic: Traffic;
    maxTraffic: number;
    expirationTime?: Date | null;
    maxClientCount: number;
    activeClientCount?: number | null;
}

export class Traffic implements ITraffic {
    sentTraffic!: number;
    receivedTraffic!: number;
    sent!: number;
    received!: number;

    constructor(data?: ITraffic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentTraffic = _data["sentTraffic"] !== undefined ? _data["sentTraffic"] : <any>null;
            this.receivedTraffic = _data["receivedTraffic"] !== undefined ? _data["receivedTraffic"] : <any>null;
            this.sent = _data["sent"] !== undefined ? _data["sent"] : <any>null;
            this.received = _data["received"] !== undefined ? _data["received"] : <any>null;
        }
    }

    static fromJS(data: any): Traffic {
        data = typeof data === 'object' ? data : {};
        let result = new Traffic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentTraffic"] = this.sentTraffic !== undefined ? this.sentTraffic : <any>null;
        data["receivedTraffic"] = this.receivedTraffic !== undefined ? this.receivedTraffic : <any>null;
        data["sent"] = this.sent !== undefined ? this.sent : <any>null;
        data["received"] = this.received !== undefined ? this.received : <any>null;
        return data;
    }
}

export interface ITraffic {
    sentTraffic: number;
    receivedTraffic: number;
    sent: number;
    received: number;
}

export enum SessionSuppressType {
    None = "None",
    YourSelf = "YourSelf",
    Other = "Other",
}

export enum VersionStatus {
    Unknown = "Unknown",
    Latest = "Latest",
    Old = "Old",
    Deprecated = "Deprecated",
}

export class PublishInfo implements IPublishInfo {
    version!: string;
    updateInfoUrl!: string;
    packageUrl!: string;
    googlePlayUrl?: string | null;
    installationPageUrl!: string;
    releaseDate!: Date;
    deprecatedVersion!: string;
    notificationDelay!: string;

    constructor(data?: IPublishInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.updateInfoUrl = _data["updateInfoUrl"] !== undefined ? _data["updateInfoUrl"] : <any>null;
            this.packageUrl = _data["packageUrl"] !== undefined ? _data["packageUrl"] : <any>null;
            this.googlePlayUrl = _data["googlePlayUrl"] !== undefined ? _data["googlePlayUrl"] : <any>null;
            this.installationPageUrl = _data["installationPageUrl"] !== undefined ? _data["installationPageUrl"] : <any>null;
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>null;
            this.deprecatedVersion = _data["deprecatedVersion"] !== undefined ? _data["deprecatedVersion"] : <any>null;
            this.notificationDelay = _data["notificationDelay"] !== undefined ? _data["notificationDelay"] : <any>null;
        }
    }

    static fromJS(data: any): PublishInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PublishInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["updateInfoUrl"] = this.updateInfoUrl !== undefined ? this.updateInfoUrl : <any>null;
        data["packageUrl"] = this.packageUrl !== undefined ? this.packageUrl : <any>null;
        data["googlePlayUrl"] = this.googlePlayUrl !== undefined ? this.googlePlayUrl : <any>null;
        data["installationPageUrl"] = this.installationPageUrl !== undefined ? this.installationPageUrl : <any>null;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>null;
        data["deprecatedVersion"] = this.deprecatedVersion !== undefined ? this.deprecatedVersion : <any>null;
        data["notificationDelay"] = this.notificationDelay !== undefined ? this.notificationDelay : <any>null;
        return data;
    }
}

export interface IPublishInfo {
    version: string;
    updateInfoUrl: string;
    packageUrl: string;
    googlePlayUrl?: string | null;
    installationPageUrl: string;
    releaseDate: Date;
    deprecatedVersion: string;
    notificationDelay: string;
}

export class UiCultureInfo implements IUiCultureInfo {
    code!: string;
    nativeName!: string;

    constructor(data?: IUiCultureInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.nativeName = _data["nativeName"] !== undefined ? _data["nativeName"] : <any>null;
        }
    }

    static fromJS(data: any): UiCultureInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UiCultureInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["nativeName"] = this.nativeName !== undefined ? this.nativeName : <any>null;
        return data;
    }
}

export interface IUiCultureInfo {
    code: string;
    nativeName: string;
}

export enum BillingPurchaseState {
    None = "None",
    Started = "Started",
    Processing = "Processing",
}

export class ClientProfileInfo implements IClientProfileInfo {
    clientProfileId!: string;
    clientProfileName!: string;
    supportId?: string | null;
    customData?: string | null;
    isPremiumLocationSelected!: boolean;
    isPremiumAccount!: boolean;
    tokenId!: string;
    hostNames!: string[];
    isValidHostName!: boolean;
    isBuiltIn!: boolean;
    isForAccount!: boolean;
    accessCode?: string | null;
    locationInfos!: ClientServerLocationInfo[];
    selectedLocationInfo?: ClientServerLocationInfo | null;

    constructor(data?: IClientProfileInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hostNames = [];
            this.locationInfos = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileId = _data["clientProfileId"] !== undefined ? _data["clientProfileId"] : <any>null;
            this.clientProfileName = _data["clientProfileName"] !== undefined ? _data["clientProfileName"] : <any>null;
            this.supportId = _data["supportId"] !== undefined ? _data["supportId"] : <any>null;
            this.customData = _data["customData"] !== undefined ? _data["customData"] : <any>null;
            this.isPremiumLocationSelected = _data["isPremiumLocationSelected"] !== undefined ? _data["isPremiumLocationSelected"] : <any>null;
            this.isPremiumAccount = _data["isPremiumAccount"] !== undefined ? _data["isPremiumAccount"] : <any>null;
            this.tokenId = _data["tokenId"] !== undefined ? _data["tokenId"] : <any>null;
            if (Array.isArray(_data["hostNames"])) {
                this.hostNames = [] as any;
                for (let item of _data["hostNames"])
                    this.hostNames!.push(item);
            }
            else {
                this.hostNames = <any>null;
            }
            this.isValidHostName = _data["isValidHostName"] !== undefined ? _data["isValidHostName"] : <any>null;
            this.isBuiltIn = _data["isBuiltIn"] !== undefined ? _data["isBuiltIn"] : <any>null;
            this.isForAccount = _data["isForAccount"] !== undefined ? _data["isForAccount"] : <any>null;
            this.accessCode = _data["accessCode"] !== undefined ? _data["accessCode"] : <any>null;
            if (Array.isArray(_data["locationInfos"])) {
                this.locationInfos = [] as any;
                for (let item of _data["locationInfos"])
                    this.locationInfos!.push(ClientServerLocationInfo.fromJS(item));
            }
            else {
                this.locationInfos = <any>null;
            }
            this.selectedLocationInfo = _data["selectedLocationInfo"] ? ClientServerLocationInfo.fromJS(_data["selectedLocationInfo"]) : <any>null;
        }
    }

    static fromJS(data: any): ClientProfileInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileId"] = this.clientProfileId !== undefined ? this.clientProfileId : <any>null;
        data["clientProfileName"] = this.clientProfileName !== undefined ? this.clientProfileName : <any>null;
        data["supportId"] = this.supportId !== undefined ? this.supportId : <any>null;
        data["customData"] = this.customData !== undefined ? this.customData : <any>null;
        data["isPremiumLocationSelected"] = this.isPremiumLocationSelected !== undefined ? this.isPremiumLocationSelected : <any>null;
        data["isPremiumAccount"] = this.isPremiumAccount !== undefined ? this.isPremiumAccount : <any>null;
        data["tokenId"] = this.tokenId !== undefined ? this.tokenId : <any>null;
        if (Array.isArray(this.hostNames)) {
            data["hostNames"] = [];
            for (let item of this.hostNames)
                data["hostNames"].push(item);
        }
        data["isValidHostName"] = this.isValidHostName !== undefined ? this.isValidHostName : <any>null;
        data["isBuiltIn"] = this.isBuiltIn !== undefined ? this.isBuiltIn : <any>null;
        data["isForAccount"] = this.isForAccount !== undefined ? this.isForAccount : <any>null;
        data["accessCode"] = this.accessCode !== undefined ? this.accessCode : <any>null;
        if (Array.isArray(this.locationInfos)) {
            data["locationInfos"] = [];
            for (let item of this.locationInfos)
                data["locationInfos"].push(item.toJSON());
        }
        data["selectedLocationInfo"] = this.selectedLocationInfo ? this.selectedLocationInfo.toJSON() : <any>null;
        return data;
    }
}

export interface IClientProfileInfo {
    clientProfileId: string;
    clientProfileName: string;
    supportId?: string | null;
    customData?: string | null;
    isPremiumLocationSelected: boolean;
    isPremiumAccount: boolean;
    tokenId: string;
    hostNames: string[];
    isValidHostName: boolean;
    isBuiltIn: boolean;
    isForAccount: boolean;
    accessCode?: string | null;
    locationInfos: ClientServerLocationInfo[];
    selectedLocationInfo?: ClientServerLocationInfo | null;
}

export class ConfigParams implements IConfigParams {
    availableCultures!: string[];
    strings?: AppStrings | null;

    constructor(data?: IConfigParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.availableCultures = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["availableCultures"])) {
                this.availableCultures = [] as any;
                for (let item of _data["availableCultures"])
                    this.availableCultures!.push(item);
            }
            else {
                this.availableCultures = <any>null;
            }
            this.strings = _data["strings"] ? AppStrings.fromJS(_data["strings"]) : <any>null;
        }
    }

    static fromJS(data: any): ConfigParams {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.availableCultures)) {
            data["availableCultures"] = [];
            for (let item of this.availableCultures)
                data["availableCultures"].push(item);
        }
        data["strings"] = this.strings ? this.strings.toJSON() : <any>null;
        return data;
    }
}

export interface IConfigParams {
    availableCultures: string[];
    strings?: AppStrings | null;
}

export class AppStrings implements IAppStrings {
    appName!: string;
    disconnect!: string;
    connect!: string;
    disconnected!: string;
    exit!: string;
    manage!: string;
    msgAccessKeyAdded!: string;
    msgAccessKeyUpdated!: string;
    msgCantReadAccessKey!: string;
    msgUnsupportedContent!: string;
    open!: string;
    openInBrowser!: string;

    constructor(data?: IAppStrings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appName = _data["appName"] !== undefined ? _data["appName"] : <any>null;
            this.disconnect = _data["disconnect"] !== undefined ? _data["disconnect"] : <any>null;
            this.connect = _data["connect"] !== undefined ? _data["connect"] : <any>null;
            this.disconnected = _data["disconnected"] !== undefined ? _data["disconnected"] : <any>null;
            this.exit = _data["exit"] !== undefined ? _data["exit"] : <any>null;
            this.manage = _data["manage"] !== undefined ? _data["manage"] : <any>null;
            this.msgAccessKeyAdded = _data["msgAccessKeyAdded"] !== undefined ? _data["msgAccessKeyAdded"] : <any>null;
            this.msgAccessKeyUpdated = _data["msgAccessKeyUpdated"] !== undefined ? _data["msgAccessKeyUpdated"] : <any>null;
            this.msgCantReadAccessKey = _data["msgCantReadAccessKey"] !== undefined ? _data["msgCantReadAccessKey"] : <any>null;
            this.msgUnsupportedContent = _data["msgUnsupportedContent"] !== undefined ? _data["msgUnsupportedContent"] : <any>null;
            this.open = _data["open"] !== undefined ? _data["open"] : <any>null;
            this.openInBrowser = _data["openInBrowser"] !== undefined ? _data["openInBrowser"] : <any>null;
        }
    }

    static fromJS(data: any): AppStrings {
        data = typeof data === 'object' ? data : {};
        let result = new AppStrings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName !== undefined ? this.appName : <any>null;
        data["disconnect"] = this.disconnect !== undefined ? this.disconnect : <any>null;
        data["connect"] = this.connect !== undefined ? this.connect : <any>null;
        data["disconnected"] = this.disconnected !== undefined ? this.disconnected : <any>null;
        data["exit"] = this.exit !== undefined ? this.exit : <any>null;
        data["manage"] = this.manage !== undefined ? this.manage : <any>null;
        data["msgAccessKeyAdded"] = this.msgAccessKeyAdded !== undefined ? this.msgAccessKeyAdded : <any>null;
        data["msgAccessKeyUpdated"] = this.msgAccessKeyUpdated !== undefined ? this.msgAccessKeyUpdated : <any>null;
        data["msgCantReadAccessKey"] = this.msgCantReadAccessKey !== undefined ? this.msgCantReadAccessKey : <any>null;
        data["msgUnsupportedContent"] = this.msgUnsupportedContent !== undefined ? this.msgUnsupportedContent : <any>null;
        data["open"] = this.open !== undefined ? this.open : <any>null;
        data["openInBrowser"] = this.openInBrowser !== undefined ? this.openInBrowser : <any>null;
        return data;
    }
}

export interface IAppStrings {
    appName: string;
    disconnect: string;
    connect: string;
    disconnected: string;
    exit: string;
    manage: string;
    msgAccessKeyAdded: string;
    msgAccessKeyUpdated: string;
    msgCantReadAccessKey: string;
    msgUnsupportedContent: string;
    open: string;
    openInBrowser: string;
}

export enum ConnectPlanId {
    Normal = "Normal",
    PremiumByTrial = "PremiumByTrial",
    PremiumByRewardedAd = "PremiumByRewardedAd",
    Status = "Status",
}

export class DeviceAppInfo implements IDeviceAppInfo {
    appId!: string;
    appName!: string;
    iconPng!: string;

    constructor(data?: IDeviceAppInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"] !== undefined ? _data["appId"] : <any>null;
            this.appName = _data["appName"] !== undefined ? _data["appName"] : <any>null;
            this.iconPng = _data["iconPng"] !== undefined ? _data["iconPng"] : <any>null;
        }
    }

    static fromJS(data: any): DeviceAppInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAppInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId !== undefined ? this.appId : <any>null;
        data["appName"] = this.appName !== undefined ? this.appName : <any>null;
        data["iconPng"] = this.iconPng !== undefined ? this.iconPng : <any>null;
        return data;
    }
}

export interface IDeviceAppInfo {
    appId: string;
    appName: string;
    iconPng: string;
}

export class SubscriptionPlan implements ISubscriptionPlan {
    subscriptionPlanId!: string;
    planPrice!: string;

    constructor(data?: ISubscriptionPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionPlanId = _data["subscriptionPlanId"] !== undefined ? _data["subscriptionPlanId"] : <any>null;
            this.planPrice = _data["planPrice"] !== undefined ? _data["planPrice"] : <any>null;
        }
    }

    static fromJS(data: any): SubscriptionPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPlanId"] = this.subscriptionPlanId !== undefined ? this.subscriptionPlanId : <any>null;
        data["planPrice"] = this.planPrice !== undefined ? this.planPrice : <any>null;
        return data;
    }
}

export interface ISubscriptionPlan {
    subscriptionPlanId: string;
    planPrice: string;
}

export class ClientProfileUpdateParams implements IClientProfileUpdateParams {
    clientProfileName?: PatchOfString | null;
    isFavorite?: PatchOfBoolean | null;
    selectedLocation?: PatchOfString | null;
    customData?: PatchOfString | null;
    isPremiumLocationSelected?: PatchOfBoolean | null;
    accessCode?: PatchOfString | null;

    constructor(data?: IClientProfileUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileName = _data["clientProfileName"] ? PatchOfString.fromJS(_data["clientProfileName"]) : <any>null;
            this.isFavorite = _data["isFavorite"] ? PatchOfBoolean.fromJS(_data["isFavorite"]) : <any>null;
            this.selectedLocation = _data["selectedLocation"] ? PatchOfString.fromJS(_data["selectedLocation"]) : <any>null;
            this.customData = _data["customData"] ? PatchOfString.fromJS(_data["customData"]) : <any>null;
            this.isPremiumLocationSelected = _data["isPremiumLocationSelected"] ? PatchOfBoolean.fromJS(_data["isPremiumLocationSelected"]) : <any>null;
            this.accessCode = _data["accessCode"] ? PatchOfString.fromJS(_data["accessCode"]) : <any>null;
        }
    }

    static fromJS(data: any): ClientProfileUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileName"] = this.clientProfileName ? this.clientProfileName.toJSON() : <any>null;
        data["isFavorite"] = this.isFavorite ? this.isFavorite.toJSON() : <any>null;
        data["selectedLocation"] = this.selectedLocation ? this.selectedLocation.toJSON() : <any>null;
        data["customData"] = this.customData ? this.customData.toJSON() : <any>null;
        data["isPremiumLocationSelected"] = this.isPremiumLocationSelected ? this.isPremiumLocationSelected.toJSON() : <any>null;
        data["accessCode"] = this.accessCode ? this.accessCode.toJSON() : <any>null;
        return data;
    }
}

export interface IClientProfileUpdateParams {
    clientProfileName?: PatchOfString | null;
    isFavorite?: PatchOfBoolean | null;
    selectedLocation?: PatchOfString | null;
    customData?: PatchOfString | null;
    isPremiumLocationSelected?: PatchOfBoolean | null;
    accessCode?: PatchOfString | null;
}

export class PatchOfString implements IPatchOfString {
    value?: string | null;

    constructor(data?: IPatchOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfString {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfString {
    value?: string | null;
}

export class PatchOfBoolean implements IPatchOfBoolean {
    value!: boolean;

    constructor(data?: IPatchOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfBoolean {
    value: boolean;
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

export class ApiException extends Error {
    statusCode: number;
    response: string | null;
    exceptionTypeName: string | null = null;
    exceptionTypeFullName: string | null = null;
    headers: unknown;
    data: { [key: string]: unknown } = {};

    constructor(
        message: string,
        statusCode: number,
        response?: unknown,
        headers?: unknown,
        innerException?: Error | null
    ) {
        const apiError = ApiException.getApiError(response);

        // Let have response as string to show in toString
        const responseStr: string | null = response instanceof String || typeof response === 'string'
            ? response.toString() : JSON.stringify(response);

        // Call super with build message
        super(ApiException.buildMessage(apiError, message, statusCode, responseStr));

        // Set properties
        this.statusCode = statusCode;
        this.response = responseStr;
        this.headers = headers;

        // Try copy data from ApiError
        if (apiError) {
            Object.keys(apiError.data).forEach((key) => {
                if (apiError)
                    this.data[key] = apiError.data[key];
            });
            this.exceptionTypeName = apiError.typeName;
            this.exceptionTypeFullName = apiError.typeFullName;
        }

        if (innerException) {
            this.stack = innerException.stack;
        }
    }

    // Try to convert an ApiError to an ApiException. it usually comes from unknown type
    public static fromApiError(apiError: unknown): ApiException {
        if (!apiError)
            throw new Error('apiError can not be null!');

        const apiErrorObj = this.getApiError(apiError);
        return new ApiException(apiErrorObj?.message || 'Unknown Error!', 500, apiError, null, null);
    }

    private static buildMessage(
        apiError: IApiErrorCamel | null,
        message: string,
        statusCode: number,
        response: string | null
    ): string {
        if (apiError)
            return apiError.message || '';

        return `${message}\n\nStatus: ${statusCode}\nResponse:\n${response?.substring(0, Math.min(512, response.length))}`;
    }

    override toString(): string {
        return `HTTP Response:\n\n${this.response}\n\n${super.toString()}`;
    }

    private static getApiError(apiError: unknown): IApiErrorCamel | null {
        if (!apiError)
            return null;

        // Check if it's a string and try to parse it
        if (typeof apiError === 'string') {
            try {
                apiError = JSON.parse(apiError);
            } catch {
                return null;
            }
        }

        // Check if it's a camelCase object by looking for typeName
        const apiErrorCamel: IApiErrorCamel = apiError as IApiErrorCamel;
        if (apiErrorCamel.typeName) {
            return {
                data: apiErrorCamel.data || {},
                typeName: apiErrorCamel.typeName || null,
                typeFullName: apiErrorCamel.typeFullName || null,
                message: apiErrorCamel.message || null
            };
        }

        // Check if it's a PascalCase object by looking for TypeName
        const apiErrorPascal: IApiErrorPascal = apiError as IApiErrorPascal;
        if (apiErrorPascal.TypeName) {
            return {
                data: apiErrorPascal.Data || {},
                typeName: apiErrorPascal.TypeName || null,
                typeFullName: apiErrorPascal.TypeFullName || null,
                message: apiErrorPascal.Message || null
            };
        }

        // Return null if not a valid PascalCase object
        return null;
    }
}

interface IApiErrorCamel {
    data: { [key: string]: unknown };
    typeName: string | null;
    typeFullName: string | null;
    message: string | null;
}
interface IApiErrorPascal {
    Data: { [key: string]: unknown };
    TypeName: string | null;
    TypeFullName: string | null;
    Message: string | null;
}