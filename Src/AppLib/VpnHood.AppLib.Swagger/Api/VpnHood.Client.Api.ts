//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    get( cancelToken?: CancelToken): Promise<AppAccount> {
        let url_ = this.baseUrl + "/api/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<AppAccount> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppAccount.fromJS(resultData200);
            return Promise.resolve<AppAccount>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppAccount>(null as any);
    }

    refresh( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    isSigninWithGoogleSupported( cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/is-signin-with-google-supported";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsSigninWithGoogleSupported(_response);
        });
    }

    protected processIsSigninWithGoogleSupported(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    signInWithGoogle( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/signin-with-google";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignInWithGoogle(_response);
        });
    }

    protected processSignInWithGoogle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    signOut( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/account/sign-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    listAccessKeys(subscriptionId: string, cancelToken?: CancelToken): Promise<string[]> {
        let url_ = this.baseUrl + "/api/account/subscriptions/{subscriptionId}/access-keys";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new globalThis.Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAccessKeys(_response);
        });
    }

    protected processListAccessKeys(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class AppClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    configure(configParams: ConfigParams, cancelToken?: CancelToken): Promise<AppData> {
        let url_ = this.baseUrl + "/api/app/configure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(configParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfigure(_response);
        });
    }

    protected processConfigure(response: AxiosResponse): Promise<AppData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppData.fromJS(resultData200);
            return Promise.resolve<AppData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppData>(null as any);
    }

    getConfig( cancelToken?: CancelToken): Promise<AppData> {
        let url_ = this.baseUrl + "/api/app/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConfig(_response);
        });
    }

    protected processGetConfig(response: AxiosResponse): Promise<AppData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppData.fromJS(resultData200);
            return Promise.resolve<AppData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppData>(null as any);
    }

    getIpFilters( cancelToken?: CancelToken): Promise<IpFilters> {
        let url_ = this.baseUrl + "/api/app/ip-filters";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIpFilters(_response);
        });
    }

    protected processGetIpFilters(response: AxiosResponse): Promise<IpFilters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IpFilters.fromJS(resultData200);
            return Promise.resolve<IpFilters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IpFilters>(null as any);
    }

    setIpFilters(ipFilters: IpFilters, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/ip-filters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ipFilters);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetIpFilters(_response);
        });
    }

    protected processSetIpFilters(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getState( cancelToken?: CancelToken): Promise<AppState> {
        let url_ = this.baseUrl + "/api/app/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetState(_response);
        });
    }

    protected processGetState(response: AxiosResponse): Promise<AppState> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppState.fromJS(resultData200);
            return Promise.resolve<AppState>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppState>(null as any);
    }

    connect(clientProfileId?: string | null | undefined, serverLocation?: string | null | undefined, planId?: ConnectPlanId | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/connect?";
        if (clientProfileId !== undefined && clientProfileId !== null)
            url_ += "clientProfileId=" + encodeURIComponent("" + clientProfileId) + "&";
        if (serverLocation !== undefined && serverLocation !== null)
            url_ += "serverLocation=" + encodeURIComponent("" + serverLocation) + "&";
        if (planId === null)
            throw new globalThis.Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnect(_response);
        });
    }

    protected processConnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    diagnose(clientProfileId?: string | null | undefined, serverLocation?: string | null | undefined, planId?: ConnectPlanId | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/diagnose?";
        if (clientProfileId !== undefined && clientProfileId !== null)
            url_ += "clientProfileId=" + encodeURIComponent("" + clientProfileId) + "&";
        if (serverLocation !== undefined && serverLocation !== null)
            url_ += "serverLocation=" + encodeURIComponent("" + serverLocation) + "&";
        if (planId === null)
            throw new globalThis.Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDiagnose(_response);
        });
    }

    protected processDiagnose(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    disconnect( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/disconnect";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDisconnect(_response);
        });
    }

    protected processDisconnect(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    clearLastError( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/clear-last-error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearLastError(_response);
        });
    }

    protected processClearLastError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    extendByRewardedAd( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/extend-by-rewarded-ad";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExtendByRewardedAd(_response);
        });
    }

    protected processExtendByRewardedAd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    setUserSettings(userSettings: UserSettings, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/user-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userSettings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetUserSettings(_response);
        });
    }

    protected processSetUserSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    log( cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/app/log.txt";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLog(_response);
        });
    }

    protected processLog(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    getInstalledApps( cancelToken?: CancelToken): Promise<DeviceAppInfo[]> {
        let url_ = this.baseUrl + "/api/app/installed-apps";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInstalledApps(_response);
        });
    }

    protected processGetInstalledApps(response: AxiosResponse): Promise<DeviceAppInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceAppInfo.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<DeviceAppInfo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceAppInfo[]>(null as any);
    }

    versionCheck( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/version-check";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVersionCheck(_response);
        });
    }

    protected processVersionCheck(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    versionCheckPostpone( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/version-check-postpone";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVersionCheckPostpone(_response);
        });
    }

    protected processVersionCheckPostpone(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    processTypes(exceptionType: ExceptionType, errorCode: SessionErrorCode, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/process-types?";
        if (exceptionType === undefined || exceptionType === null)
            throw new globalThis.Error("The parameter 'exceptionType' must be defined and cannot be null.");
        else
            url_ += "exceptionType=" + encodeURIComponent("" + exceptionType) + "&";
        if (errorCode === undefined || errorCode === null)
            throw new globalThis.Error("The parameter 'errorCode' must be defined and cannot be null.");
        else
            url_ += "errorCode=" + encodeURIComponent("" + errorCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProcessTypes(_response);
        });
    }

    protected processProcessTypes(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    setUserReview(userReview: AppUserReview, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/user-review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userReview);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetUserReview(_response);
        });
    }

    protected processSetUserReview(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getCountries( cancelToken?: CancelToken): Promise<CountryInfo[]> {
        let url_ = this.baseUrl + "/api/app/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCountries(_response);
        });
    }

    protected processGetCountries(response: AxiosResponse): Promise<CountryInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryInfo.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<CountryInfo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CountryInfo[]>(null as any);
    }

    internalAdDismiss(result: ShowAdResult, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/internal-ad/dismiss?";
        if (result === undefined || result === null)
            throw new globalThis.Error("The parameter 'result' must be defined and cannot be null.");
        else
            url_ += "result=" + encodeURIComponent("" + result) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInternalAdDismiss(_response);
        });
    }

    protected processInternalAdDismiss(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    internalAdError(errorMessage: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/internal-ad/error?";
        if (errorMessage === undefined || errorMessage === null)
            throw new globalThis.Error("The parameter 'errorMessage' must be defined and cannot be null.");
        else
            url_ += "errorMessage=" + encodeURIComponent("" + errorMessage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInternalAdError(_response);
        });
    }

    protected processInternalAdError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    removePremium(profileId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/app/remove-premium?";
        if (profileId === undefined || profileId === null)
            throw new globalThis.Error("The parameter 'profileId' must be defined and cannot be null.");
        else
            url_ += "profileId=" + encodeURIComponent("" + profileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemovePremium(_response);
        });
    }

    protected processRemovePremium(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BillingClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getSubscriptionPlans( cancelToken?: CancelToken): Promise<SubscriptionPlan[]> {
        let url_ = this.baseUrl + "/api/billing/subscription-plans";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSubscriptionPlans(_response);
        });
    }

    protected processGetSubscriptionPlans(response: AxiosResponse): Promise<SubscriptionPlan[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscriptionPlan.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<SubscriptionPlan[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubscriptionPlan[]>(null as any);
    }

    purchase(planId: string, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/billing/purchase?";
        if (planId === undefined || planId === null)
            throw new globalThis.Error("The parameter 'planId' must be defined and cannot be null.");
        else
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPurchase(_response);
        });
    }

    protected processPurchase(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    getPurchaseOptions( cancelToken?: CancelToken): Promise<AppPurchaseOptions> {
        let url_ = this.baseUrl + "/api/billing/purchase-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPurchaseOptions(_response);
        });
    }

    protected processGetPurchaseOptions(response: AxiosResponse): Promise<AppPurchaseOptions> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppPurchaseOptions.fromJS(resultData200);
            return Promise.resolve<AppPurchaseOptions>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppPurchaseOptions>(null as any);
    }
}

export class ClientProfileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    addByAccessKey(accessKey: string, cancelToken?: CancelToken): Promise<ClientProfileInfo> {
        let url_ = this.baseUrl + "/api/client-profiles/access-keys?";
        if (accessKey === undefined || accessKey === null)
            throw new globalThis.Error("The parameter 'accessKey' must be defined and cannot be null.");
        else
            url_ += "accessKey=" + encodeURIComponent("" + accessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddByAccessKey(_response);
        });
    }

    protected processAddByAccessKey(response: AxiosResponse): Promise<ClientProfileInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientProfileInfo.fromJS(resultData200);
            return Promise.resolve<ClientProfileInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfileInfo>(null as any);
    }

    get(clientProfileId: string, cancelToken?: CancelToken): Promise<ClientProfileInfo> {
        let url_ = this.baseUrl + "/api/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new globalThis.Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ClientProfileInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientProfileInfo.fromJS(resultData200);
            return Promise.resolve<ClientProfileInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfileInfo>(null as any);
    }

    update(clientProfileId: string, updateParams: ClientProfileUpdateParams, cancelToken?: CancelToken): Promise<ClientProfileInfo> {
        let url_ = this.baseUrl + "/api/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new globalThis.Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<ClientProfileInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientProfileInfo.fromJS(resultData200);
            return Promise.resolve<ClientProfileInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientProfileInfo>(null as any);
    }

    delete(clientProfileId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/client-profiles/{clientProfileId}";
        if (clientProfileId === undefined || clientProfileId === null)
            throw new globalThis.Error("The parameter 'clientProfileId' must be defined.");
        url_ = url_.replace("{clientProfileId}", encodeURIComponent("" + clientProfileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class IntentsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    requestQuickLaunch( cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/intents/request-quick-launch";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestQuickLaunch(_response);
        });
    }

    protected processRequestQuickLaunch(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    requestUserReview( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/intents/request-user-review";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestUserReview(_response);
        });
    }

    protected processRequestUserReview(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    requestNotification( cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/intents/request-notification";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestNotification(_response);
        });
    }

    protected processRequestNotification(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    openSystemKillSwitchSettings( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/intents/open-system-kill-switch-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOpenSystemKillSwitchSettings(_response);
        });
    }

    protected processOpenSystemKillSwitchSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    openSystemAlwaysOnSettings( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/intents/open-system-always-on-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOpenSystemAlwaysOnSettings(_response);
        });
    }

    protected processOpenSystemAlwaysOnSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    openSystemSettings( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/intents/open-system-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOpenSystemSettings(_response);
        });
    }

    protected processOpenSystemSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    openAppSystemSettings( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/intents/open-app-system-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOpenAppSystemSettings(_response);
        });
    }

    protected processOpenAppSystemSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    openAppSystemNotificationSettings( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/intents/open-app-system-notification-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOpenAppSystemNotificationSettings(_response);
        });
    }

    protected processOpenAppSystemNotificationSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProxyEndPointClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getDevice( cancelToken?: CancelToken): Promise<AppProxyEndPointInfo> {
        let url_ = this.baseUrl + "/api/proxy-endpoints/device";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDevice(_response);
        });
    }

    protected processGetDevice(response: AxiosResponse): Promise<AppProxyEndPointInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppProxyEndPointInfo.fromJS(resultData200);
            return Promise.resolve<AppProxyEndPointInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppProxyEndPointInfo>(null as any);
    }

    list( cancelToken?: CancelToken): Promise<AppProxyEndPointInfo[]> {
        let url_ = this.baseUrl + "/api/proxy-endpoints";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<AppProxyEndPointInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppProxyEndPointInfo.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return Promise.resolve<AppProxyEndPointInfo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppProxyEndPointInfo[]>(null as any);
    }

    add(proxyEndPoint: ProxyEndPoint, cancelToken?: CancelToken): Promise<AppProxyEndPointInfo> {
        let url_ = this.baseUrl + "/api/proxy-endpoints";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(proxyEndPoint);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<AppProxyEndPointInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppProxyEndPointInfo.fromJS(resultData200);
            return Promise.resolve<AppProxyEndPointInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppProxyEndPointInfo>(null as any);
    }

    deleteAll( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/proxy-endpoints";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    parse(text: string, defaults: ProxyEndPointDefaults, cancelToken?: CancelToken): Promise<AppProxyEndPointInfo> {
        let url_ = this.baseUrl + "/api/proxy-endpoints/parse?";
        if (text === undefined || text === null)
            throw new globalThis.Error("The parameter 'text' must be defined and cannot be null.");
        else
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(defaults);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processParse(_response);
        });
    }

    protected processParse(response: AxiosResponse): Promise<AppProxyEndPointInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppProxyEndPointInfo.fromJS(resultData200);
            return Promise.resolve<AppProxyEndPointInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppProxyEndPointInfo>(null as any);
    }

    update(proxyEndPointId: string, proxyEndPoint: ProxyEndPoint, cancelToken?: CancelToken): Promise<AppProxyEndPointInfo> {
        let url_ = this.baseUrl + "/api/proxy-endpoints/{proxyEndPointId}";
        if (proxyEndPointId === undefined || proxyEndPointId === null)
            throw new globalThis.Error("The parameter 'proxyEndPointId' must be defined.");
        url_ = url_.replace("{proxyEndPointId}", encodeURIComponent("" + proxyEndPointId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(proxyEndPoint);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<AppProxyEndPointInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppProxyEndPointInfo.fromJS(resultData200);
            return Promise.resolve<AppProxyEndPointInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppProxyEndPointInfo>(null as any);
    }

    delete(proxyEndPointId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/proxy-endpoints/{proxyEndPointId}";
        if (proxyEndPointId === undefined || proxyEndPointId === null)
            throw new globalThis.Error("The parameter 'proxyEndPointId' must be defined.");
        url_ = url_.replace("{proxyEndPointId}", encodeURIComponent("" + proxyEndPointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    resetState( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/proxy-endpoints/reset-state";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetState(_response);
        });
    }

    protected processResetState(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    import(text: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/proxy-endpoints/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(text);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AppAccount implements IAppAccount {
    userId!: string;
    name?: string | null;
    email?: string | null;
    subscriptionId?: string | null;
    providerPlanId?: string | null;
    createdTime?: Date | null;
    expirationTime?: Date | null;
    priceAmount?: number | null;
    priceCurrency?: string | null;
    isAutoRenew?: boolean | null;
    providerSubscriptionId?: string | null;

    constructor(data?: IAppAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : null as any;
            this.name = _data["name"] !== undefined ? _data["name"] : null as any;
            this.email = _data["email"] !== undefined ? _data["email"] : null as any;
            this.subscriptionId = _data["subscriptionId"] !== undefined ? _data["subscriptionId"] : null as any;
            this.providerPlanId = _data["providerPlanId"] !== undefined ? _data["providerPlanId"] : null as any;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : null as any;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : null as any;
            this.priceAmount = _data["priceAmount"] !== undefined ? _data["priceAmount"] : null as any;
            this.priceCurrency = _data["priceCurrency"] !== undefined ? _data["priceCurrency"] : null as any;
            this.isAutoRenew = _data["isAutoRenew"] !== undefined ? _data["isAutoRenew"] : null as any;
            this.providerSubscriptionId = _data["providerSubscriptionId"] !== undefined ? _data["providerSubscriptionId"] : null as any;
        }
    }

    static fromJS(data: any): AppAccount {
        data = typeof data === 'object' ? data : {};
        let result = new AppAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : null as any;
        data["name"] = this.name !== undefined ? this.name : null as any;
        data["email"] = this.email !== undefined ? this.email : null as any;
        data["subscriptionId"] = this.subscriptionId !== undefined ? this.subscriptionId : null as any;
        data["providerPlanId"] = this.providerPlanId !== undefined ? this.providerPlanId : null as any;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : null as any;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : null as any;
        data["priceAmount"] = this.priceAmount !== undefined ? this.priceAmount : null as any;
        data["priceCurrency"] = this.priceCurrency !== undefined ? this.priceCurrency : null as any;
        data["isAutoRenew"] = this.isAutoRenew !== undefined ? this.isAutoRenew : null as any;
        data["providerSubscriptionId"] = this.providerSubscriptionId !== undefined ? this.providerSubscriptionId : null as any;
        return data;
    }
}

export interface IAppAccount {
    userId: string;
    name?: string | null;
    email?: string | null;
    subscriptionId?: string | null;
    providerPlanId?: string | null;
    createdTime?: Date | null;
    expirationTime?: Date | null;
    priceAmount?: number | null;
    priceCurrency?: string | null;
    isAutoRenew?: boolean | null;
    providerSubscriptionId?: string | null;
}

export class AppData implements IAppData {
    features!: AppFeatures;
    intentFeatures!: AppIntentFeatures;
    state!: AppState;
    userSettings!: UserSettings;
    clientProfileInfos!: ClientProfileInfo[];
    availableCultureInfos!: UiCultureInfo[];

    constructor(data?: IAppData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.features = new AppFeatures();
            this.intentFeatures = new AppIntentFeatures();
            this.state = new AppState();
            this.userSettings = new UserSettings();
            this.clientProfileInfos = [];
            this.availableCultureInfos = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.features = _data["features"] ? AppFeatures.fromJS(_data["features"]) : new AppFeatures();
            this.intentFeatures = _data["intentFeatures"] ? AppIntentFeatures.fromJS(_data["intentFeatures"]) : new AppIntentFeatures();
            this.state = _data["state"] ? AppState.fromJS(_data["state"]) : new AppState();
            this.userSettings = _data["userSettings"] ? UserSettings.fromJS(_data["userSettings"]) : new UserSettings();
            if (Array.isArray(_data["clientProfileInfos"])) {
                this.clientProfileInfos = [] as any;
                for (let item of _data["clientProfileInfos"])
                    this.clientProfileInfos!.push(ClientProfileInfo.fromJS(item));
            }
            else {
                this.clientProfileInfos = null as any;
            }
            if (Array.isArray(_data["availableCultureInfos"])) {
                this.availableCultureInfos = [] as any;
                for (let item of _data["availableCultureInfos"])
                    this.availableCultureInfos!.push(UiCultureInfo.fromJS(item));
            }
            else {
                this.availableCultureInfos = null as any;
            }
        }
    }

    static fromJS(data: any): AppData {
        data = typeof data === 'object' ? data : {};
        let result = new AppData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["features"] = this.features ? this.features.toJSON() : null as any;
        data["intentFeatures"] = this.intentFeatures ? this.intentFeatures.toJSON() : null as any;
        data["state"] = this.state ? this.state.toJSON() : null as any;
        data["userSettings"] = this.userSettings ? this.userSettings.toJSON() : null as any;
        if (Array.isArray(this.clientProfileInfos)) {
            data["clientProfileInfos"] = [];
            for (let item of this.clientProfileInfos)
                data["clientProfileInfos"].push(item ? item.toJSON() : null as any);
        }
        if (Array.isArray(this.availableCultureInfos)) {
            data["availableCultureInfos"] = [];
            for (let item of this.availableCultureInfos)
                data["availableCultureInfos"].push(item ? item.toJSON() : null as any);
        }
        return data;
    }
}

export interface IAppData {
    features: AppFeatures;
    intentFeatures: AppIntentFeatures;
    state: AppState;
    userSettings: UserSettings;
    clientProfileInfos: ClientProfileInfo[];
    availableCultureInfos: UiCultureInfo[];
}

export class AppFeatures implements IAppFeatures {
    appId!: string;
    appName!: string;
    isExcludeAppsSupported!: boolean;
    isIncludeAppsSupported!: boolean;
    uiName?: string | null;
    isPremiumFlagSupported!: boolean;
    isAddAccessKeySupported!: boolean;
    builtInClientProfileId?: string | null;
    isAccountSupported!: boolean;
    isBillingSupported!: boolean;
    isTcpProxySupported!: boolean;
    isUserReviewSupported!: boolean;
    isTv!: boolean;
    gaMeasurementId?: string | null;
    clientId!: string;
    isDebugMode!: boolean;
    debugCommands!: string[];
    isLocalNetworkSupported!: boolean;
    adjustForSystemBars!: boolean;
    allowEndPointStrategy!: boolean;
    autoRemoveExpiredPremium!: boolean;
    isAdSupported!: boolean;
    webUiPort?: number | null;
    premiumFeatures!: AppFeature[];
    channelProtocols!: ChannelProtocol[];
    customData?: any | null;
    version!: string;

    constructor(data?: IAppFeatures) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.debugCommands = [];
            this.premiumFeatures = [];
            this.channelProtocols = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"] !== undefined ? _data["appId"] : null as any;
            this.appName = _data["appName"] !== undefined ? _data["appName"] : null as any;
            this.isExcludeAppsSupported = _data["isExcludeAppsSupported"] !== undefined ? _data["isExcludeAppsSupported"] : null as any;
            this.isIncludeAppsSupported = _data["isIncludeAppsSupported"] !== undefined ? _data["isIncludeAppsSupported"] : null as any;
            this.uiName = _data["uiName"] !== undefined ? _data["uiName"] : null as any;
            this.isPremiumFlagSupported = _data["isPremiumFlagSupported"] !== undefined ? _data["isPremiumFlagSupported"] : null as any;
            this.isAddAccessKeySupported = _data["isAddAccessKeySupported"] !== undefined ? _data["isAddAccessKeySupported"] : null as any;
            this.builtInClientProfileId = _data["builtInClientProfileId"] !== undefined ? _data["builtInClientProfileId"] : null as any;
            this.isAccountSupported = _data["isAccountSupported"] !== undefined ? _data["isAccountSupported"] : null as any;
            this.isBillingSupported = _data["isBillingSupported"] !== undefined ? _data["isBillingSupported"] : null as any;
            this.isTcpProxySupported = _data["isTcpProxySupported"] !== undefined ? _data["isTcpProxySupported"] : null as any;
            this.isUserReviewSupported = _data["isUserReviewSupported"] !== undefined ? _data["isUserReviewSupported"] : null as any;
            this.isTv = _data["isTv"] !== undefined ? _data["isTv"] : null as any;
            this.gaMeasurementId = _data["gaMeasurementId"] !== undefined ? _data["gaMeasurementId"] : null as any;
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : null as any;
            this.isDebugMode = _data["isDebugMode"] !== undefined ? _data["isDebugMode"] : null as any;
            if (Array.isArray(_data["debugCommands"])) {
                this.debugCommands = [] as any;
                for (let item of _data["debugCommands"])
                    this.debugCommands!.push(item);
            }
            else {
                this.debugCommands = null as any;
            }
            this.isLocalNetworkSupported = _data["isLocalNetworkSupported"] !== undefined ? _data["isLocalNetworkSupported"] : null as any;
            this.adjustForSystemBars = _data["adjustForSystemBars"] !== undefined ? _data["adjustForSystemBars"] : null as any;
            this.allowEndPointStrategy = _data["allowEndPointStrategy"] !== undefined ? _data["allowEndPointStrategy"] : null as any;
            this.autoRemoveExpiredPremium = _data["autoRemoveExpiredPremium"] !== undefined ? _data["autoRemoveExpiredPremium"] : null as any;
            this.isAdSupported = _data["isAdSupported"] !== undefined ? _data["isAdSupported"] : null as any;
            this.webUiPort = _data["webUiPort"] !== undefined ? _data["webUiPort"] : null as any;
            if (Array.isArray(_data["premiumFeatures"])) {
                this.premiumFeatures = [] as any;
                for (let item of _data["premiumFeatures"])
                    this.premiumFeatures!.push(item);
            }
            else {
                this.premiumFeatures = null as any;
            }
            if (Array.isArray(_data["channelProtocols"])) {
                this.channelProtocols = [] as any;
                for (let item of _data["channelProtocols"])
                    this.channelProtocols!.push(item);
            }
            else {
                this.channelProtocols = null as any;
            }
            this.customData = _data["customData"] !== undefined ? _data["customData"] : null as any;
            this.version = _data["version"] !== undefined ? _data["version"] : null as any;
        }
    }

    static fromJS(data: any): AppFeatures {
        data = typeof data === 'object' ? data : {};
        let result = new AppFeatures();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId !== undefined ? this.appId : null as any;
        data["appName"] = this.appName !== undefined ? this.appName : null as any;
        data["isExcludeAppsSupported"] = this.isExcludeAppsSupported !== undefined ? this.isExcludeAppsSupported : null as any;
        data["isIncludeAppsSupported"] = this.isIncludeAppsSupported !== undefined ? this.isIncludeAppsSupported : null as any;
        data["uiName"] = this.uiName !== undefined ? this.uiName : null as any;
        data["isPremiumFlagSupported"] = this.isPremiumFlagSupported !== undefined ? this.isPremiumFlagSupported : null as any;
        data["isAddAccessKeySupported"] = this.isAddAccessKeySupported !== undefined ? this.isAddAccessKeySupported : null as any;
        data["builtInClientProfileId"] = this.builtInClientProfileId !== undefined ? this.builtInClientProfileId : null as any;
        data["isAccountSupported"] = this.isAccountSupported !== undefined ? this.isAccountSupported : null as any;
        data["isBillingSupported"] = this.isBillingSupported !== undefined ? this.isBillingSupported : null as any;
        data["isTcpProxySupported"] = this.isTcpProxySupported !== undefined ? this.isTcpProxySupported : null as any;
        data["isUserReviewSupported"] = this.isUserReviewSupported !== undefined ? this.isUserReviewSupported : null as any;
        data["isTv"] = this.isTv !== undefined ? this.isTv : null as any;
        data["gaMeasurementId"] = this.gaMeasurementId !== undefined ? this.gaMeasurementId : null as any;
        data["clientId"] = this.clientId !== undefined ? this.clientId : null as any;
        data["isDebugMode"] = this.isDebugMode !== undefined ? this.isDebugMode : null as any;
        if (Array.isArray(this.debugCommands)) {
            data["debugCommands"] = [];
            for (let item of this.debugCommands)
                data["debugCommands"].push(item);
        }
        data["isLocalNetworkSupported"] = this.isLocalNetworkSupported !== undefined ? this.isLocalNetworkSupported : null as any;
        data["adjustForSystemBars"] = this.adjustForSystemBars !== undefined ? this.adjustForSystemBars : null as any;
        data["allowEndPointStrategy"] = this.allowEndPointStrategy !== undefined ? this.allowEndPointStrategy : null as any;
        data["autoRemoveExpiredPremium"] = this.autoRemoveExpiredPremium !== undefined ? this.autoRemoveExpiredPremium : null as any;
        data["isAdSupported"] = this.isAdSupported !== undefined ? this.isAdSupported : null as any;
        data["webUiPort"] = this.webUiPort !== undefined ? this.webUiPort : null as any;
        if (Array.isArray(this.premiumFeatures)) {
            data["premiumFeatures"] = [];
            for (let item of this.premiumFeatures)
                data["premiumFeatures"].push(item);
        }
        if (Array.isArray(this.channelProtocols)) {
            data["channelProtocols"] = [];
            for (let item of this.channelProtocols)
                data["channelProtocols"].push(item);
        }
        data["customData"] = this.customData !== undefined ? this.customData : null as any;
        data["version"] = this.version !== undefined ? this.version : null as any;
        return data;
    }
}

export interface IAppFeatures {
    appId: string;
    appName: string;
    isExcludeAppsSupported: boolean;
    isIncludeAppsSupported: boolean;
    uiName?: string | null;
    isPremiumFlagSupported: boolean;
    isAddAccessKeySupported: boolean;
    builtInClientProfileId?: string | null;
    isAccountSupported: boolean;
    isBillingSupported: boolean;
    isTcpProxySupported: boolean;
    isUserReviewSupported: boolean;
    isTv: boolean;
    gaMeasurementId?: string | null;
    clientId: string;
    isDebugMode: boolean;
    debugCommands: string[];
    isLocalNetworkSupported: boolean;
    adjustForSystemBars: boolean;
    allowEndPointStrategy: boolean;
    autoRemoveExpiredPremium: boolean;
    isAdSupported: boolean;
    webUiPort?: number | null;
    premiumFeatures: AppFeature[];
    channelProtocols: ChannelProtocol[];
    customData?: any | null;
    version: string;
}

export enum AppFeature {
    QuickLaunch = "QuickLaunch",
    AlwaysOn = "AlwaysOn",
    CustomDns = "CustomDns",
    AppIpFilter = "AppIpFilter",
    AdapterIpFilter = "AdapterIpFilter",
}

export enum ChannelProtocol {
    Quic = "Quic",
    Udp = "Udp",
    Tcp = "Tcp",
}

export class AppIntentFeatures implements IAppIntentFeatures {
    isUserReviewSupported!: boolean;
    isQuickLaunchSupported!: boolean;
    isRequestQuickLaunchSupported!: boolean;
    isRequestNotificationSupported!: boolean;
    isSystemPrivateDnsSettingsSupported!: boolean;
    isSystemKillSwitchSettingsSupported!: boolean;
    isSystemAlwaysOnSettingsSupported!: boolean;
    isSystemSettingsSupported!: boolean;
    isAppSystemSettingsSupported!: boolean;
    isAppSystemNotificationSettingsSupported!: boolean;

    constructor(data?: IAppIntentFeatures) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserReviewSupported = _data["isUserReviewSupported"] !== undefined ? _data["isUserReviewSupported"] : null as any;
            this.isQuickLaunchSupported = _data["isQuickLaunchSupported"] !== undefined ? _data["isQuickLaunchSupported"] : null as any;
            this.isRequestQuickLaunchSupported = _data["isRequestQuickLaunchSupported"] !== undefined ? _data["isRequestQuickLaunchSupported"] : null as any;
            this.isRequestNotificationSupported = _data["isRequestNotificationSupported"] !== undefined ? _data["isRequestNotificationSupported"] : null as any;
            this.isSystemPrivateDnsSettingsSupported = _data["isSystemPrivateDnsSettingsSupported"] !== undefined ? _data["isSystemPrivateDnsSettingsSupported"] : null as any;
            this.isSystemKillSwitchSettingsSupported = _data["isSystemKillSwitchSettingsSupported"] !== undefined ? _data["isSystemKillSwitchSettingsSupported"] : null as any;
            this.isSystemAlwaysOnSettingsSupported = _data["isSystemAlwaysOnSettingsSupported"] !== undefined ? _data["isSystemAlwaysOnSettingsSupported"] : null as any;
            this.isSystemSettingsSupported = _data["isSystemSettingsSupported"] !== undefined ? _data["isSystemSettingsSupported"] : null as any;
            this.isAppSystemSettingsSupported = _data["isAppSystemSettingsSupported"] !== undefined ? _data["isAppSystemSettingsSupported"] : null as any;
            this.isAppSystemNotificationSettingsSupported = _data["isAppSystemNotificationSettingsSupported"] !== undefined ? _data["isAppSystemNotificationSettingsSupported"] : null as any;
        }
    }

    static fromJS(data: any): AppIntentFeatures {
        data = typeof data === 'object' ? data : {};
        let result = new AppIntentFeatures();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserReviewSupported"] = this.isUserReviewSupported !== undefined ? this.isUserReviewSupported : null as any;
        data["isQuickLaunchSupported"] = this.isQuickLaunchSupported !== undefined ? this.isQuickLaunchSupported : null as any;
        data["isRequestQuickLaunchSupported"] = this.isRequestQuickLaunchSupported !== undefined ? this.isRequestQuickLaunchSupported : null as any;
        data["isRequestNotificationSupported"] = this.isRequestNotificationSupported !== undefined ? this.isRequestNotificationSupported : null as any;
        data["isSystemPrivateDnsSettingsSupported"] = this.isSystemPrivateDnsSettingsSupported !== undefined ? this.isSystemPrivateDnsSettingsSupported : null as any;
        data["isSystemKillSwitchSettingsSupported"] = this.isSystemKillSwitchSettingsSupported !== undefined ? this.isSystemKillSwitchSettingsSupported : null as any;
        data["isSystemAlwaysOnSettingsSupported"] = this.isSystemAlwaysOnSettingsSupported !== undefined ? this.isSystemAlwaysOnSettingsSupported : null as any;
        data["isSystemSettingsSupported"] = this.isSystemSettingsSupported !== undefined ? this.isSystemSettingsSupported : null as any;
        data["isAppSystemSettingsSupported"] = this.isAppSystemSettingsSupported !== undefined ? this.isAppSystemSettingsSupported : null as any;
        data["isAppSystemNotificationSettingsSupported"] = this.isAppSystemNotificationSettingsSupported !== undefined ? this.isAppSystemNotificationSettingsSupported : null as any;
        return data;
    }
}

export interface IAppIntentFeatures {
    isUserReviewSupported: boolean;
    isQuickLaunchSupported: boolean;
    isRequestQuickLaunchSupported: boolean;
    isRequestNotificationSupported: boolean;
    isSystemPrivateDnsSettingsSupported: boolean;
    isSystemKillSwitchSettingsSupported: boolean;
    isSystemAlwaysOnSettingsSupported: boolean;
    isSystemSettingsSupported: boolean;
    isAppSystemSettingsSupported: boolean;
    isAppSystemNotificationSettingsSupported: boolean;
}

export class AppState implements IAppState {
    configTime!: Date;
    connectionState!: AppConnectionState;
    sessionInfo?: AppSessionInfo | null;
    sessionStatus?: AppSessionStatus | null;
    connectRequestTime?: Date | null;
    lastError?: ApiError | null;
    clientProfile?: ClientProfileBaseInfo | null;
    isIdle!: boolean;
    promptForLog!: boolean;
    logExists!: boolean;
    hasDiagnoseRequested!: boolean;
    clientCountryCode?: string | null;
    clientCountryName?: string | null;
    updaterStatus?: AppUpdaterStatus | null;
    canDisconnect!: boolean;
    canConnect!: boolean;
    canDiagnose!: boolean;
    userReviewRecommended!: number;
    isQuickLaunchRecommended!: boolean;
    currentUiCultureInfo!: UiCultureInfo;
    systemUiCultureInfo!: UiCultureInfo;
    purchaseState?: BillingPurchaseState | null;
    systemBarsInfo!: SystemBarsInfo;
    isNotificationEnabled?: boolean | null;
    systemPrivateDns?: PrivateDns | null;
    isWaitingForInternalAd?: boolean | null;
    stateProgress?: number | null;
    isDiagnosing!: boolean;
    channelProtocol!: ChannelProtocol;
    isProxyEndPointActive!: boolean;

    constructor(data?: IAppState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.currentUiCultureInfo = new UiCultureInfo();
            this.systemUiCultureInfo = new UiCultureInfo();
            this.systemBarsInfo = new SystemBarsInfo();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configTime = _data["configTime"] ? new Date(_data["configTime"].toString()) : null as any;
            this.connectionState = _data["connectionState"] !== undefined ? _data["connectionState"] : null as any;
            this.sessionInfo = _data["sessionInfo"] ? AppSessionInfo.fromJS(_data["sessionInfo"]) : null as any;
            this.sessionStatus = _data["sessionStatus"] ? AppSessionStatus.fromJS(_data["sessionStatus"]) : null as any;
            this.connectRequestTime = _data["connectRequestTime"] ? new Date(_data["connectRequestTime"].toString()) : null as any;
            this.lastError = _data["lastError"] ? ApiError.fromJS(_data["lastError"]) : null as any;
            this.clientProfile = _data["clientProfile"] ? ClientProfileBaseInfo.fromJS(_data["clientProfile"]) : null as any;
            this.isIdle = _data["isIdle"] !== undefined ? _data["isIdle"] : null as any;
            this.promptForLog = _data["promptForLog"] !== undefined ? _data["promptForLog"] : null as any;
            this.logExists = _data["logExists"] !== undefined ? _data["logExists"] : null as any;
            this.hasDiagnoseRequested = _data["hasDiagnoseRequested"] !== undefined ? _data["hasDiagnoseRequested"] : null as any;
            this.clientCountryCode = _data["clientCountryCode"] !== undefined ? _data["clientCountryCode"] : null as any;
            this.clientCountryName = _data["clientCountryName"] !== undefined ? _data["clientCountryName"] : null as any;
            this.updaterStatus = _data["updaterStatus"] ? AppUpdaterStatus.fromJS(_data["updaterStatus"]) : null as any;
            this.canDisconnect = _data["canDisconnect"] !== undefined ? _data["canDisconnect"] : null as any;
            this.canConnect = _data["canConnect"] !== undefined ? _data["canConnect"] : null as any;
            this.canDiagnose = _data["canDiagnose"] !== undefined ? _data["canDiagnose"] : null as any;
            this.userReviewRecommended = _data["userReviewRecommended"] !== undefined ? _data["userReviewRecommended"] : null as any;
            this.isQuickLaunchRecommended = _data["isQuickLaunchRecommended"] !== undefined ? _data["isQuickLaunchRecommended"] : null as any;
            this.currentUiCultureInfo = _data["currentUiCultureInfo"] ? UiCultureInfo.fromJS(_data["currentUiCultureInfo"]) : new UiCultureInfo();
            this.systemUiCultureInfo = _data["systemUiCultureInfo"] ? UiCultureInfo.fromJS(_data["systemUiCultureInfo"]) : new UiCultureInfo();
            this.purchaseState = _data["purchaseState"] !== undefined ? _data["purchaseState"] : null as any;
            this.systemBarsInfo = _data["systemBarsInfo"] ? SystemBarsInfo.fromJS(_data["systemBarsInfo"]) : new SystemBarsInfo();
            this.isNotificationEnabled = _data["isNotificationEnabled"] !== undefined ? _data["isNotificationEnabled"] : null as any;
            this.systemPrivateDns = _data["systemPrivateDns"] ? PrivateDns.fromJS(_data["systemPrivateDns"]) : null as any;
            this.isWaitingForInternalAd = _data["isWaitingForInternalAd"] !== undefined ? _data["isWaitingForInternalAd"] : null as any;
            this.stateProgress = _data["stateProgress"] !== undefined ? _data["stateProgress"] : null as any;
            this.isDiagnosing = _data["isDiagnosing"] !== undefined ? _data["isDiagnosing"] : null as any;
            this.channelProtocol = _data["channelProtocol"] !== undefined ? _data["channelProtocol"] : null as any;
            this.isProxyEndPointActive = _data["isProxyEndPointActive"] !== undefined ? _data["isProxyEndPointActive"] : null as any;
        }
    }

    static fromJS(data: any): AppState {
        data = typeof data === 'object' ? data : {};
        let result = new AppState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configTime"] = this.configTime ? this.configTime.toISOString() : null as any;
        data["connectionState"] = this.connectionState !== undefined ? this.connectionState : null as any;
        data["sessionInfo"] = this.sessionInfo ? this.sessionInfo.toJSON() : null as any;
        data["sessionStatus"] = this.sessionStatus ? this.sessionStatus.toJSON() : null as any;
        data["connectRequestTime"] = this.connectRequestTime ? this.connectRequestTime.toISOString() : null as any;
        data["lastError"] = this.lastError ? this.lastError.toJSON() : null as any;
        data["clientProfile"] = this.clientProfile ? this.clientProfile.toJSON() : null as any;
        data["isIdle"] = this.isIdle !== undefined ? this.isIdle : null as any;
        data["promptForLog"] = this.promptForLog !== undefined ? this.promptForLog : null as any;
        data["logExists"] = this.logExists !== undefined ? this.logExists : null as any;
        data["hasDiagnoseRequested"] = this.hasDiagnoseRequested !== undefined ? this.hasDiagnoseRequested : null as any;
        data["clientCountryCode"] = this.clientCountryCode !== undefined ? this.clientCountryCode : null as any;
        data["clientCountryName"] = this.clientCountryName !== undefined ? this.clientCountryName : null as any;
        data["updaterStatus"] = this.updaterStatus ? this.updaterStatus.toJSON() : null as any;
        data["canDisconnect"] = this.canDisconnect !== undefined ? this.canDisconnect : null as any;
        data["canConnect"] = this.canConnect !== undefined ? this.canConnect : null as any;
        data["canDiagnose"] = this.canDiagnose !== undefined ? this.canDiagnose : null as any;
        data["userReviewRecommended"] = this.userReviewRecommended !== undefined ? this.userReviewRecommended : null as any;
        data["isQuickLaunchRecommended"] = this.isQuickLaunchRecommended !== undefined ? this.isQuickLaunchRecommended : null as any;
        data["currentUiCultureInfo"] = this.currentUiCultureInfo ? this.currentUiCultureInfo.toJSON() : null as any;
        data["systemUiCultureInfo"] = this.systemUiCultureInfo ? this.systemUiCultureInfo.toJSON() : null as any;
        data["purchaseState"] = this.purchaseState !== undefined ? this.purchaseState : null as any;
        data["systemBarsInfo"] = this.systemBarsInfo ? this.systemBarsInfo.toJSON() : null as any;
        data["isNotificationEnabled"] = this.isNotificationEnabled !== undefined ? this.isNotificationEnabled : null as any;
        data["systemPrivateDns"] = this.systemPrivateDns ? this.systemPrivateDns.toJSON() : null as any;
        data["isWaitingForInternalAd"] = this.isWaitingForInternalAd !== undefined ? this.isWaitingForInternalAd : null as any;
        data["stateProgress"] = this.stateProgress !== undefined ? this.stateProgress : null as any;
        data["isDiagnosing"] = this.isDiagnosing !== undefined ? this.isDiagnosing : null as any;
        data["channelProtocol"] = this.channelProtocol !== undefined ? this.channelProtocol : null as any;
        data["isProxyEndPointActive"] = this.isProxyEndPointActive !== undefined ? this.isProxyEndPointActive : null as any;
        return data;
    }
}

export interface IAppState {
    configTime: Date;
    connectionState: AppConnectionState;
    sessionInfo?: AppSessionInfo | null;
    sessionStatus?: AppSessionStatus | null;
    connectRequestTime?: Date | null;
    lastError?: ApiError | null;
    clientProfile?: ClientProfileBaseInfo | null;
    isIdle: boolean;
    promptForLog: boolean;
    logExists: boolean;
    hasDiagnoseRequested: boolean;
    clientCountryCode?: string | null;
    clientCountryName?: string | null;
    updaterStatus?: AppUpdaterStatus | null;
    canDisconnect: boolean;
    canConnect: boolean;
    canDiagnose: boolean;
    userReviewRecommended: number;
    isQuickLaunchRecommended: boolean;
    currentUiCultureInfo: UiCultureInfo;
    systemUiCultureInfo: UiCultureInfo;
    purchaseState?: BillingPurchaseState | null;
    systemBarsInfo: SystemBarsInfo;
    isNotificationEnabled?: boolean | null;
    systemPrivateDns?: PrivateDns | null;
    isWaitingForInternalAd?: boolean | null;
    stateProgress?: number | null;
    isDiagnosing: boolean;
    channelProtocol: ChannelProtocol;
    isProxyEndPointActive: boolean;
}

export enum AppConnectionState {
    None = "None",
    Initializing = "Initializing",
    Waiting = "Waiting",
    WaitingForAd = "WaitingForAd",
    Diagnosing = "Diagnosing",
    ValidatingProxies = "ValidatingProxies",
    FindingReachableServer = "FindingReachableServer",
    FindingBestServer = "FindingBestServer",
    Connecting = "Connecting",
    Connected = "Connected",
    Unstable = "Unstable",
    Disconnecting = "Disconnecting",
}

export class AppSessionInfo implements IAppSessionInfo {
    accessInfo?: AccessInfo | null;
    isDnsServersAccepted!: boolean;
    isLocalNetworkAllowed!: boolean;
    serverLocationInfo?: ServerLocationInfo | null;
    isPremiumSession!: boolean;
    suppressedTo!: SessionSuppressType;
    dnsServers!: string[];
    serverVersion!: string;
    clientPublicIpAddress!: string;
    createdTime!: Date;
    channelProtocols!: ChannelProtocol[];
    isTcpProxySupported!: boolean;
    isTcpPacketSupported!: boolean;
    canChangeTcpProxy!: boolean;

    constructor(data?: IAppSessionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.dnsServers = [];
            this.channelProtocols = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessInfo = _data["accessInfo"] ? AccessInfo.fromJS(_data["accessInfo"]) : null as any;
            this.isDnsServersAccepted = _data["isDnsServersAccepted"] !== undefined ? _data["isDnsServersAccepted"] : null as any;
            this.isLocalNetworkAllowed = _data["isLocalNetworkAllowed"] !== undefined ? _data["isLocalNetworkAllowed"] : null as any;
            this.serverLocationInfo = _data["serverLocationInfo"] ? ServerLocationInfo.fromJS(_data["serverLocationInfo"]) : null as any;
            this.isPremiumSession = _data["isPremiumSession"] !== undefined ? _data["isPremiumSession"] : null as any;
            this.suppressedTo = _data["suppressedTo"] !== undefined ? _data["suppressedTo"] : null as any;
            if (Array.isArray(_data["dnsServers"])) {
                this.dnsServers = [] as any;
                for (let item of _data["dnsServers"])
                    this.dnsServers!.push(item);
            }
            else {
                this.dnsServers = null as any;
            }
            this.serverVersion = _data["serverVersion"] !== undefined ? _data["serverVersion"] : null as any;
            this.clientPublicIpAddress = _data["clientPublicIpAddress"] !== undefined ? _data["clientPublicIpAddress"] : null as any;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : null as any;
            if (Array.isArray(_data["channelProtocols"])) {
                this.channelProtocols = [] as any;
                for (let item of _data["channelProtocols"])
                    this.channelProtocols!.push(item);
            }
            else {
                this.channelProtocols = null as any;
            }
            this.isTcpProxySupported = _data["isTcpProxySupported"] !== undefined ? _data["isTcpProxySupported"] : null as any;
            this.isTcpPacketSupported = _data["isTcpPacketSupported"] !== undefined ? _data["isTcpPacketSupported"] : null as any;
            this.canChangeTcpProxy = _data["canChangeTcpProxy"] !== undefined ? _data["canChangeTcpProxy"] : null as any;
        }
    }

    static fromJS(data: any): AppSessionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AppSessionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessInfo"] = this.accessInfo ? this.accessInfo.toJSON() : null as any;
        data["isDnsServersAccepted"] = this.isDnsServersAccepted !== undefined ? this.isDnsServersAccepted : null as any;
        data["isLocalNetworkAllowed"] = this.isLocalNetworkAllowed !== undefined ? this.isLocalNetworkAllowed : null as any;
        data["serverLocationInfo"] = this.serverLocationInfo ? this.serverLocationInfo.toJSON() : null as any;
        data["isPremiumSession"] = this.isPremiumSession !== undefined ? this.isPremiumSession : null as any;
        data["suppressedTo"] = this.suppressedTo !== undefined ? this.suppressedTo : null as any;
        if (Array.isArray(this.dnsServers)) {
            data["dnsServers"] = [];
            for (let item of this.dnsServers)
                data["dnsServers"].push(item);
        }
        data["serverVersion"] = this.serverVersion !== undefined ? this.serverVersion : null as any;
        data["clientPublicIpAddress"] = this.clientPublicIpAddress !== undefined ? this.clientPublicIpAddress : null as any;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : null as any;
        if (Array.isArray(this.channelProtocols)) {
            data["channelProtocols"] = [];
            for (let item of this.channelProtocols)
                data["channelProtocols"].push(item);
        }
        data["isTcpProxySupported"] = this.isTcpProxySupported !== undefined ? this.isTcpProxySupported : null as any;
        data["isTcpPacketSupported"] = this.isTcpPacketSupported !== undefined ? this.isTcpPacketSupported : null as any;
        data["canChangeTcpProxy"] = this.canChangeTcpProxy !== undefined ? this.canChangeTcpProxy : null as any;
        return data;
    }
}

export interface IAppSessionInfo {
    accessInfo?: AccessInfo | null;
    isDnsServersAccepted: boolean;
    isLocalNetworkAllowed: boolean;
    serverLocationInfo?: ServerLocationInfo | null;
    isPremiumSession: boolean;
    suppressedTo: SessionSuppressType;
    dnsServers: string[];
    serverVersion: string;
    clientPublicIpAddress: string;
    createdTime: Date;
    channelProtocols: ChannelProtocol[];
    isTcpProxySupported: boolean;
    isTcpPacketSupported: boolean;
    canChangeTcpProxy: boolean;
}

export class AccessInfo implements IAccessInfo {
    isNew!: boolean;
    createdTime!: Date;
    lastUsedTime!: Date;
    expirationTime?: Date | null;
    isPremium!: boolean;
    maxCycleTraffic!: number;
    maxTotalTraffic!: number;
    maxDeviceCount!: number;
    deviceLifeSpan!: number;
    devicesSummary?: AccessDevicesSummary | null;

    constructor(data?: IAccessInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isNew = _data["isNew"] !== undefined ? _data["isNew"] : null as any;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : null as any;
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : null as any;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : null as any;
            this.isPremium = _data["isPremium"] !== undefined ? _data["isPremium"] : null as any;
            this.maxCycleTraffic = _data["maxCycleTraffic"] !== undefined ? _data["maxCycleTraffic"] : null as any;
            this.maxTotalTraffic = _data["maxTotalTraffic"] !== undefined ? _data["maxTotalTraffic"] : null as any;
            this.maxDeviceCount = _data["maxDeviceCount"] !== undefined ? _data["maxDeviceCount"] : null as any;
            this.deviceLifeSpan = _data["deviceLifeSpan"] !== undefined ? _data["deviceLifeSpan"] : null as any;
            this.devicesSummary = _data["devicesSummary"] ? AccessDevicesSummary.fromJS(_data["devicesSummary"]) : null as any;
        }
    }

    static fromJS(data: any): AccessInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AccessInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNew"] = this.isNew !== undefined ? this.isNew : null as any;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : null as any;
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : null as any;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : null as any;
        data["isPremium"] = this.isPremium !== undefined ? this.isPremium : null as any;
        data["maxCycleTraffic"] = this.maxCycleTraffic !== undefined ? this.maxCycleTraffic : null as any;
        data["maxTotalTraffic"] = this.maxTotalTraffic !== undefined ? this.maxTotalTraffic : null as any;
        data["maxDeviceCount"] = this.maxDeviceCount !== undefined ? this.maxDeviceCount : null as any;
        data["deviceLifeSpan"] = this.deviceLifeSpan !== undefined ? this.deviceLifeSpan : null as any;
        data["devicesSummary"] = this.devicesSummary ? this.devicesSummary.toJSON() : null as any;
        return data;
    }
}

export interface IAccessInfo {
    isNew: boolean;
    createdTime: Date;
    lastUsedTime: Date;
    expirationTime?: Date | null;
    isPremium: boolean;
    maxCycleTraffic: number;
    maxTotalTraffic: number;
    maxDeviceCount: number;
    deviceLifeSpan: number;
    devicesSummary?: AccessDevicesSummary | null;
}

export class AccessDevicesSummary implements IAccessDevicesSummary {
    deviceCount!: number;
    hasMoreDevices!: boolean;
    devices?: AccessDevice[] | null;

    constructor(data?: IAccessDevicesSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceCount = _data["deviceCount"] !== undefined ? _data["deviceCount"] : null as any;
            this.hasMoreDevices = _data["hasMoreDevices"] !== undefined ? _data["hasMoreDevices"] : null as any;
            if (Array.isArray(_data["devices"])) {
                this.devices = [] as any;
                for (let item of _data["devices"])
                    this.devices!.push(AccessDevice.fromJS(item));
            }
            else {
                this.devices = null as any;
            }
        }
    }

    static fromJS(data: any): AccessDevicesSummary {
        data = typeof data === 'object' ? data : {};
        let result = new AccessDevicesSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceCount"] = this.deviceCount !== undefined ? this.deviceCount : null as any;
        data["hasMoreDevices"] = this.hasMoreDevices !== undefined ? this.hasMoreDevices : null as any;
        if (Array.isArray(this.devices)) {
            data["devices"] = [];
            for (let item of this.devices)
                data["devices"].push(item ? item.toJSON() : null as any);
        }
        return data;
    }
}

export interface IAccessDevicesSummary {
    deviceCount: number;
    hasMoreDevices: boolean;
    devices?: AccessDevice[] | null;
}

export class AccessDevice implements IAccessDevice {
    lastUsedTime!: Date;
    operatingSystem?: string | null;
    ipAddress?: string | null;

    constructor(data?: IAccessDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : null as any;
            this.operatingSystem = _data["operatingSystem"] !== undefined ? _data["operatingSystem"] : null as any;
            this.ipAddress = _data["ipAddress"] !== undefined ? _data["ipAddress"] : null as any;
        }
    }

    static fromJS(data: any): AccessDevice {
        data = typeof data === 'object' ? data : {};
        let result = new AccessDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : null as any;
        data["operatingSystem"] = this.operatingSystem !== undefined ? this.operatingSystem : null as any;
        data["ipAddress"] = this.ipAddress !== undefined ? this.ipAddress : null as any;
        return data;
    }
}

export interface IAccessDevice {
    lastUsedTime: Date;
    operatingSystem?: string | null;
    ipAddress?: string | null;
}

export class ServerLocationInfo implements IServerLocationInfo {
    countryCode!: string;
    regionName!: string;
    tags?: string[] | null;
    serverLocation!: string;
    countryName!: string;
    isAuto!: boolean;

    constructor(data?: IServerLocationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"] !== undefined ? _data["countryCode"] : null as any;
            this.regionName = _data["regionName"] !== undefined ? _data["regionName"] : null as any;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = null as any;
            }
            this.serverLocation = _data["serverLocation"] !== undefined ? _data["serverLocation"] : null as any;
            this.countryName = _data["countryName"] !== undefined ? _data["countryName"] : null as any;
            this.isAuto = _data["isAuto"] !== undefined ? _data["isAuto"] : null as any;
        }
    }

    static fromJS(data: any): ServerLocationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ServerLocationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode !== undefined ? this.countryCode : null as any;
        data["regionName"] = this.regionName !== undefined ? this.regionName : null as any;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["serverLocation"] = this.serverLocation !== undefined ? this.serverLocation : null as any;
        data["countryName"] = this.countryName !== undefined ? this.countryName : null as any;
        data["isAuto"] = this.isAuto !== undefined ? this.isAuto : null as any;
        return data;
    }
}

export interface IServerLocationInfo {
    countryCode: string;
    regionName: string;
    tags?: string[] | null;
    serverLocation: string;
    countryName: string;
    isAuto: boolean;
}

export enum SessionSuppressType {
    None = "None",
    YourSelf = "YourSelf",
    Other = "Other",
}

export class AppSessionStatus implements IAppSessionStatus {
    connectorStat!: AppConnectorStat;
    speed!: Traffic;
    sessionTraffic!: Traffic;
    sessionSplitTraffic!: Traffic;
    cycleTraffic!: Traffic;
    totalTraffic!: Traffic;
    tcpTunnelledCount!: number;
    tcpPassthruCount!: number;
    packetChannelCount!: number;
    unstableCount!: number;
    waitingCount!: number;
    canExtendByRewardedAd!: boolean;
    sessionMaxTraffic!: number;
    sessionExpirationTime?: Date | null;
    activeClientCount?: number | null;
    isTcpProxy!: boolean;
    isDropQuic!: boolean;
    channelProtocol!: ChannelProtocol;

    constructor(data?: IAppSessionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.connectorStat = new AppConnectorStat();
            this.speed = new Traffic();
            this.sessionTraffic = new Traffic();
            this.sessionSplitTraffic = new Traffic();
            this.cycleTraffic = new Traffic();
            this.totalTraffic = new Traffic();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectorStat = _data["connectorStat"] ? AppConnectorStat.fromJS(_data["connectorStat"]) : new AppConnectorStat();
            this.speed = _data["speed"] ? Traffic.fromJS(_data["speed"]) : new Traffic();
            this.sessionTraffic = _data["sessionTraffic"] ? Traffic.fromJS(_data["sessionTraffic"]) : new Traffic();
            this.sessionSplitTraffic = _data["sessionSplitTraffic"] ? Traffic.fromJS(_data["sessionSplitTraffic"]) : new Traffic();
            this.cycleTraffic = _data["cycleTraffic"] ? Traffic.fromJS(_data["cycleTraffic"]) : new Traffic();
            this.totalTraffic = _data["totalTraffic"] ? Traffic.fromJS(_data["totalTraffic"]) : new Traffic();
            this.tcpTunnelledCount = _data["tcpTunnelledCount"] !== undefined ? _data["tcpTunnelledCount"] : null as any;
            this.tcpPassthruCount = _data["tcpPassthruCount"] !== undefined ? _data["tcpPassthruCount"] : null as any;
            this.packetChannelCount = _data["packetChannelCount"] !== undefined ? _data["packetChannelCount"] : null as any;
            this.unstableCount = _data["unstableCount"] !== undefined ? _data["unstableCount"] : null as any;
            this.waitingCount = _data["waitingCount"] !== undefined ? _data["waitingCount"] : null as any;
            this.canExtendByRewardedAd = _data["canExtendByRewardedAd"] !== undefined ? _data["canExtendByRewardedAd"] : null as any;
            this.sessionMaxTraffic = _data["sessionMaxTraffic"] !== undefined ? _data["sessionMaxTraffic"] : null as any;
            this.sessionExpirationTime = _data["sessionExpirationTime"] ? new Date(_data["sessionExpirationTime"].toString()) : null as any;
            this.activeClientCount = _data["activeClientCount"] !== undefined ? _data["activeClientCount"] : null as any;
            this.isTcpProxy = _data["isTcpProxy"] !== undefined ? _data["isTcpProxy"] : null as any;
            this.isDropQuic = _data["isDropQuic"] !== undefined ? _data["isDropQuic"] : null as any;
            this.channelProtocol = _data["channelProtocol"] !== undefined ? _data["channelProtocol"] : null as any;
        }
    }

    static fromJS(data: any): AppSessionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new AppSessionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectorStat"] = this.connectorStat ? this.connectorStat.toJSON() : null as any;
        data["speed"] = this.speed ? this.speed.toJSON() : null as any;
        data["sessionTraffic"] = this.sessionTraffic ? this.sessionTraffic.toJSON() : null as any;
        data["sessionSplitTraffic"] = this.sessionSplitTraffic ? this.sessionSplitTraffic.toJSON() : null as any;
        data["cycleTraffic"] = this.cycleTraffic ? this.cycleTraffic.toJSON() : null as any;
        data["totalTraffic"] = this.totalTraffic ? this.totalTraffic.toJSON() : null as any;
        data["tcpTunnelledCount"] = this.tcpTunnelledCount !== undefined ? this.tcpTunnelledCount : null as any;
        data["tcpPassthruCount"] = this.tcpPassthruCount !== undefined ? this.tcpPassthruCount : null as any;
        data["packetChannelCount"] = this.packetChannelCount !== undefined ? this.packetChannelCount : null as any;
        data["unstableCount"] = this.unstableCount !== undefined ? this.unstableCount : null as any;
        data["waitingCount"] = this.waitingCount !== undefined ? this.waitingCount : null as any;
        data["canExtendByRewardedAd"] = this.canExtendByRewardedAd !== undefined ? this.canExtendByRewardedAd : null as any;
        data["sessionMaxTraffic"] = this.sessionMaxTraffic !== undefined ? this.sessionMaxTraffic : null as any;
        data["sessionExpirationTime"] = this.sessionExpirationTime ? this.sessionExpirationTime.toISOString() : null as any;
        data["activeClientCount"] = this.activeClientCount !== undefined ? this.activeClientCount : null as any;
        data["isTcpProxy"] = this.isTcpProxy !== undefined ? this.isTcpProxy : null as any;
        data["isDropQuic"] = this.isDropQuic !== undefined ? this.isDropQuic : null as any;
        data["channelProtocol"] = this.channelProtocol !== undefined ? this.channelProtocol : null as any;
        return data;
    }
}

export interface IAppSessionStatus {
    connectorStat: AppConnectorStat;
    speed: Traffic;
    sessionTraffic: Traffic;
    sessionSplitTraffic: Traffic;
    cycleTraffic: Traffic;
    totalTraffic: Traffic;
    tcpTunnelledCount: number;
    tcpPassthruCount: number;
    packetChannelCount: number;
    unstableCount: number;
    waitingCount: number;
    canExtendByRewardedAd: boolean;
    sessionMaxTraffic: number;
    sessionExpirationTime?: Date | null;
    activeClientCount?: number | null;
    isTcpProxy: boolean;
    isDropQuic: boolean;
    channelProtocol: ChannelProtocol;
}

export class AppConnectorStat implements IAppConnectorStat {
    freeConnectionCount!: number;
    reusedConnectionFailedCount!: number;
    reusedConnectionSucceededCount!: number;
    createdConnectionCount!: number;
    requestCount!: number;

    constructor(data?: IAppConnectorStat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.freeConnectionCount = _data["freeConnectionCount"] !== undefined ? _data["freeConnectionCount"] : null as any;
            this.reusedConnectionFailedCount = _data["reusedConnectionFailedCount"] !== undefined ? _data["reusedConnectionFailedCount"] : null as any;
            this.reusedConnectionSucceededCount = _data["reusedConnectionSucceededCount"] !== undefined ? _data["reusedConnectionSucceededCount"] : null as any;
            this.createdConnectionCount = _data["createdConnectionCount"] !== undefined ? _data["createdConnectionCount"] : null as any;
            this.requestCount = _data["requestCount"] !== undefined ? _data["requestCount"] : null as any;
        }
    }

    static fromJS(data: any): AppConnectorStat {
        data = typeof data === 'object' ? data : {};
        let result = new AppConnectorStat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["freeConnectionCount"] = this.freeConnectionCount !== undefined ? this.freeConnectionCount : null as any;
        data["reusedConnectionFailedCount"] = this.reusedConnectionFailedCount !== undefined ? this.reusedConnectionFailedCount : null as any;
        data["reusedConnectionSucceededCount"] = this.reusedConnectionSucceededCount !== undefined ? this.reusedConnectionSucceededCount : null as any;
        data["createdConnectionCount"] = this.createdConnectionCount !== undefined ? this.createdConnectionCount : null as any;
        data["requestCount"] = this.requestCount !== undefined ? this.requestCount : null as any;
        return data;
    }
}

export interface IAppConnectorStat {
    freeConnectionCount: number;
    reusedConnectionFailedCount: number;
    reusedConnectionSucceededCount: number;
    createdConnectionCount: number;
    requestCount: number;
}

export class Traffic implements ITraffic {
    sent!: number;
    received!: number;

    constructor(data?: ITraffic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sent = _data["sent"] !== undefined ? _data["sent"] : null as any;
            this.received = _data["received"] !== undefined ? _data["received"] : null as any;
        }
    }

    static fromJS(data: any): Traffic {
        data = typeof data === 'object' ? data : {};
        let result = new Traffic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sent"] = this.sent !== undefined ? this.sent : null as any;
        data["received"] = this.received !== undefined ? this.received : null as any;
        return data;
    }
}

export interface ITraffic {
    sent: number;
    received: number;
}

export class ApiError implements IApiError {
    typeName!: string;
    typeFullName?: string | null;
    message!: string;
    data!: { [key: string]: string; };
    innerMessage?: string | null;

    constructor(data?: IApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.data = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"] !== undefined ? _data["typeName"] : null as any;
            this.typeFullName = _data["typeFullName"] !== undefined ? _data["typeFullName"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (this.data as any)![key] = _data["data"][key] !== undefined ? _data["data"][key] : null as any;
                }
            }
            else {
                this.data = null as any;
            }
            this.innerMessage = _data["innerMessage"] !== undefined ? _data["innerMessage"] : null as any;
        }
    }

    static fromJS(data: any): ApiError {
        data = typeof data === 'object' ? data : {};
        let result = new ApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName !== undefined ? this.typeName : null as any;
        data["typeFullName"] = this.typeFullName !== undefined ? this.typeFullName : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (data["data"] as any)[key] = this.data[key] !== undefined ? this.data[key] : null as any;
            }
        }
        data["innerMessage"] = this.innerMessage !== undefined ? this.innerMessage : null as any;
        return data;
    }
}

export interface IApiError {
    typeName: string;
    typeFullName?: string | null;
    message: string;
    data: { [key: string]: string; };
    innerMessage?: string | null;
}

export class ClientProfileBaseInfo implements IClientProfileBaseInfo {
    clientProfileId!: string;
    clientProfileName!: string;
    supportId?: string | null;
    customData?: string | null;
    isPremiumLocationSelected!: boolean;
    isPremiumAccount!: boolean;
    selectedLocationInfo?: ClientServerLocationInfo | null;
    hasAccessCode!: boolean;
    customServerEndpoints?: string[] | null;

    constructor(data?: IClientProfileBaseInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileId = _data["clientProfileId"] !== undefined ? _data["clientProfileId"] : null as any;
            this.clientProfileName = _data["clientProfileName"] !== undefined ? _data["clientProfileName"] : null as any;
            this.supportId = _data["supportId"] !== undefined ? _data["supportId"] : null as any;
            this.customData = _data["customData"] !== undefined ? _data["customData"] : null as any;
            this.isPremiumLocationSelected = _data["isPremiumLocationSelected"] !== undefined ? _data["isPremiumLocationSelected"] : null as any;
            this.isPremiumAccount = _data["isPremiumAccount"] !== undefined ? _data["isPremiumAccount"] : null as any;
            this.selectedLocationInfo = _data["selectedLocationInfo"] ? ClientServerLocationInfo.fromJS(_data["selectedLocationInfo"]) : null as any;
            this.hasAccessCode = _data["hasAccessCode"] !== undefined ? _data["hasAccessCode"] : null as any;
            if (Array.isArray(_data["customServerEndpoints"])) {
                this.customServerEndpoints = [] as any;
                for (let item of _data["customServerEndpoints"])
                    this.customServerEndpoints!.push(item);
            }
            else {
                this.customServerEndpoints = null as any;
            }
        }
    }

    static fromJS(data: any): ClientProfileBaseInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileBaseInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileId"] = this.clientProfileId !== undefined ? this.clientProfileId : null as any;
        data["clientProfileName"] = this.clientProfileName !== undefined ? this.clientProfileName : null as any;
        data["supportId"] = this.supportId !== undefined ? this.supportId : null as any;
        data["customData"] = this.customData !== undefined ? this.customData : null as any;
        data["isPremiumLocationSelected"] = this.isPremiumLocationSelected !== undefined ? this.isPremiumLocationSelected : null as any;
        data["isPremiumAccount"] = this.isPremiumAccount !== undefined ? this.isPremiumAccount : null as any;
        data["selectedLocationInfo"] = this.selectedLocationInfo ? this.selectedLocationInfo.toJSON() : null as any;
        data["hasAccessCode"] = this.hasAccessCode !== undefined ? this.hasAccessCode : null as any;
        if (Array.isArray(this.customServerEndpoints)) {
            data["customServerEndpoints"] = [];
            for (let item of this.customServerEndpoints)
                data["customServerEndpoints"].push(item);
        }
        return data;
    }
}

export interface IClientProfileBaseInfo {
    clientProfileId: string;
    clientProfileName: string;
    supportId?: string | null;
    customData?: string | null;
    isPremiumLocationSelected: boolean;
    isPremiumAccount: boolean;
    selectedLocationInfo?: ClientServerLocationInfo | null;
    hasAccessCode: boolean;
    customServerEndpoints?: string[] | null;
}

export class ClientServerLocationInfo extends ServerLocationInfo implements IClientServerLocationInfo {
    isNestedCountry!: boolean;
    isDefault!: boolean;
    options!: ServerLocationOptions;

    constructor(data?: IClientServerLocationInfo) {
        super(data);
        if (!data) {
            this.options = new ServerLocationOptions();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isNestedCountry = _data["isNestedCountry"] !== undefined ? _data["isNestedCountry"] : null as any;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : null as any;
            this.options = _data["options"] ? ServerLocationOptions.fromJS(_data["options"]) : new ServerLocationOptions();
        }
    }

    static override fromJS(data: any): ClientServerLocationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientServerLocationInfo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNestedCountry"] = this.isNestedCountry !== undefined ? this.isNestedCountry : null as any;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : null as any;
        data["options"] = this.options ? this.options.toJSON() : null as any;
        super.toJSON(data);
        return data;
    }
}

export interface IClientServerLocationInfo extends IServerLocationInfo {
    isNestedCountry: boolean;
    isDefault: boolean;
    options: ServerLocationOptions;
}

export class ServerLocationOptions implements IServerLocationOptions {
    normal?: number | null;
    premiumByTrial?: number | null;
    premiumByRewardedAd?: number | null;
    premiumByPurchase!: boolean;
    premiumByCode!: boolean;
    canGoPremium!: boolean;
    hasFree!: boolean;
    hasPremium!: boolean;
    hasUnblockable!: boolean;
    prompt!: boolean;

    constructor(data?: IServerLocationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.normal = _data["normal"] !== undefined ? _data["normal"] : null as any;
            this.premiumByTrial = _data["premiumByTrial"] !== undefined ? _data["premiumByTrial"] : null as any;
            this.premiumByRewardedAd = _data["premiumByRewardedAd"] !== undefined ? _data["premiumByRewardedAd"] : null as any;
            this.premiumByPurchase = _data["premiumByPurchase"] !== undefined ? _data["premiumByPurchase"] : null as any;
            this.premiumByCode = _data["premiumByCode"] !== undefined ? _data["premiumByCode"] : null as any;
            this.canGoPremium = _data["canGoPremium"] !== undefined ? _data["canGoPremium"] : null as any;
            this.hasFree = _data["hasFree"] !== undefined ? _data["hasFree"] : null as any;
            this.hasPremium = _data["hasPremium"] !== undefined ? _data["hasPremium"] : null as any;
            this.hasUnblockable = _data["hasUnblockable"] !== undefined ? _data["hasUnblockable"] : null as any;
            this.prompt = _data["prompt"] !== undefined ? _data["prompt"] : null as any;
        }
    }

    static fromJS(data: any): ServerLocationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ServerLocationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["normal"] = this.normal !== undefined ? this.normal : null as any;
        data["premiumByTrial"] = this.premiumByTrial !== undefined ? this.premiumByTrial : null as any;
        data["premiumByRewardedAd"] = this.premiumByRewardedAd !== undefined ? this.premiumByRewardedAd : null as any;
        data["premiumByPurchase"] = this.premiumByPurchase !== undefined ? this.premiumByPurchase : null as any;
        data["premiumByCode"] = this.premiumByCode !== undefined ? this.premiumByCode : null as any;
        data["canGoPremium"] = this.canGoPremium !== undefined ? this.canGoPremium : null as any;
        data["hasFree"] = this.hasFree !== undefined ? this.hasFree : null as any;
        data["hasPremium"] = this.hasPremium !== undefined ? this.hasPremium : null as any;
        data["hasUnblockable"] = this.hasUnblockable !== undefined ? this.hasUnblockable : null as any;
        data["prompt"] = this.prompt !== undefined ? this.prompt : null as any;
        return data;
    }
}

export interface IServerLocationOptions {
    normal?: number | null;
    premiumByTrial?: number | null;
    premiumByRewardedAd?: number | null;
    premiumByPurchase: boolean;
    premiumByCode: boolean;
    canGoPremium: boolean;
    hasFree: boolean;
    hasPremium: boolean;
    hasUnblockable: boolean;
    prompt: boolean;
}

export class AppUpdaterStatus implements IAppUpdaterStatus {
    checkedTime?: Date | null;
    versionStatus!: VersionStatus;
    publishInfo?: PublishInfo | null;
    prompt!: boolean;

    constructor(data?: IAppUpdaterStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkedTime = _data["checkedTime"] ? new Date(_data["checkedTime"].toString()) : null as any;
            this.versionStatus = _data["versionStatus"] !== undefined ? _data["versionStatus"] : null as any;
            this.publishInfo = _data["publishInfo"] ? PublishInfo.fromJS(_data["publishInfo"]) : null as any;
            this.prompt = _data["prompt"] !== undefined ? _data["prompt"] : null as any;
        }
    }

    static fromJS(data: any): AppUpdaterStatus {
        data = typeof data === 'object' ? data : {};
        let result = new AppUpdaterStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkedTime"] = this.checkedTime ? this.checkedTime.toISOString() : null as any;
        data["versionStatus"] = this.versionStatus !== undefined ? this.versionStatus : null as any;
        data["publishInfo"] = this.publishInfo ? this.publishInfo.toJSON() : null as any;
        data["prompt"] = this.prompt !== undefined ? this.prompt : null as any;
        return data;
    }
}

export interface IAppUpdaterStatus {
    checkedTime?: Date | null;
    versionStatus: VersionStatus;
    publishInfo?: PublishInfo | null;
    prompt: boolean;
}

export enum VersionStatus {
    Unknown = "Unknown",
    Latest = "Latest",
    Old = "Old",
    Deprecated = "Deprecated",
}

export class PublishInfo implements IPublishInfo {
    version!: string;
    updateInfoUrl!: string;
    packageUrl!: string;
    googlePlayUrl?: string | null;
    installationPageUrl!: string;
    releaseDate!: Date;
    deprecatedVersion!: string;
    notificationDelay!: string;

    constructor(data?: IPublishInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] !== undefined ? _data["version"] : null as any;
            this.updateInfoUrl = _data["updateInfoUrl"] !== undefined ? _data["updateInfoUrl"] : null as any;
            this.packageUrl = _data["packageUrl"] !== undefined ? _data["packageUrl"] : null as any;
            this.googlePlayUrl = _data["googlePlayUrl"] !== undefined ? _data["googlePlayUrl"] : null as any;
            this.installationPageUrl = _data["installationPageUrl"] !== undefined ? _data["installationPageUrl"] : null as any;
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : null as any;
            this.deprecatedVersion = _data["deprecatedVersion"] !== undefined ? _data["deprecatedVersion"] : null as any;
            this.notificationDelay = _data["notificationDelay"] !== undefined ? _data["notificationDelay"] : null as any;
        }
    }

    static fromJS(data: any): PublishInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PublishInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version !== undefined ? this.version : null as any;
        data["updateInfoUrl"] = this.updateInfoUrl !== undefined ? this.updateInfoUrl : null as any;
        data["packageUrl"] = this.packageUrl !== undefined ? this.packageUrl : null as any;
        data["googlePlayUrl"] = this.googlePlayUrl !== undefined ? this.googlePlayUrl : null as any;
        data["installationPageUrl"] = this.installationPageUrl !== undefined ? this.installationPageUrl : null as any;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : null as any;
        data["deprecatedVersion"] = this.deprecatedVersion !== undefined ? this.deprecatedVersion : null as any;
        data["notificationDelay"] = this.notificationDelay !== undefined ? this.notificationDelay : null as any;
        return data;
    }
}

export interface IPublishInfo {
    version: string;
    updateInfoUrl: string;
    packageUrl: string;
    googlePlayUrl?: string | null;
    installationPageUrl: string;
    releaseDate: Date;
    deprecatedVersion: string;
    notificationDelay: string;
}

export class UiCultureInfo implements IUiCultureInfo {
    code!: string;
    nativeName!: string;

    constructor(data?: IUiCultureInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : null as any;
            this.nativeName = _data["nativeName"] !== undefined ? _data["nativeName"] : null as any;
        }
    }

    static fromJS(data: any): UiCultureInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UiCultureInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : null as any;
        data["nativeName"] = this.nativeName !== undefined ? this.nativeName : null as any;
        return data;
    }
}

export interface IUiCultureInfo {
    code: string;
    nativeName: string;
}

export enum BillingPurchaseState {
    None = "None",
    Started = "Started",
    Processing = "Processing",
}

export class SystemBarsInfo implements ISystemBarsInfo {
    topHeight!: number;
    bottomHeight!: number;

    constructor(data?: ISystemBarsInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.topHeight = _data["topHeight"] !== undefined ? _data["topHeight"] : null as any;
            this.bottomHeight = _data["bottomHeight"] !== undefined ? _data["bottomHeight"] : null as any;
        }
    }

    static fromJS(data: any): SystemBarsInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SystemBarsInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["topHeight"] = this.topHeight !== undefined ? this.topHeight : null as any;
        data["bottomHeight"] = this.bottomHeight !== undefined ? this.bottomHeight : null as any;
        return data;
    }
}

export interface ISystemBarsInfo {
    topHeight: number;
    bottomHeight: number;
}

export class PrivateDns implements IPrivateDns {
    isActive!: boolean;
    provider?: string | null;

    constructor(data?: IPrivateDns) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : null as any;
            this.provider = _data["provider"] !== undefined ? _data["provider"] : null as any;
        }
    }

    static fromJS(data: any): PrivateDns {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateDns();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive !== undefined ? this.isActive : null as any;
        data["provider"] = this.provider !== undefined ? this.provider : null as any;
        return data;
    }
}

export interface IPrivateDns {
    isActive: boolean;
    provider?: string | null;
}

export class UserSettings implements IUserSettings {
    isLicenseAccepted!: boolean;
    isTcpProxyPrompted!: boolean;
    isQuickLaunchPrompted!: boolean;
    cultureCode?: string | null;
    clientProfileId?: string | null;
    maxPacketChannelCount!: number;
    tunnelClientCountry!: boolean;
    appFilters!: string[];
    appFiltersMode!: FilterMode;
    channelProtocol!: ChannelProtocol;
    dropUdp!: boolean;
    useTcpProxy!: boolean;
    dropQuic!: boolean;
    allowAnonymousTracker!: boolean;
    domainFilter!: DomainFilter;
    debugData1?: string | null;
    debugData2?: string | null;
    logAnonymous!: boolean;
    includeLocalNetwork!: boolean;
    useAppIpFilter!: boolean;
    useVpnAdapterIpFilter!: boolean;
    endPointStrategy!: EndPointStrategy;
    dnsMode!: DnsMode;
    proxySettings!: AppProxySettings;
    allowRemoteAccess!: boolean;
    dnsServers!: string[];
    useUdpChannel?: boolean | null;

    constructor(data?: IUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.appFilters = [];
            this.domainFilter = new DomainFilter();
            this.proxySettings = new AppProxySettings();
            this.dnsServers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLicenseAccepted = _data["isLicenseAccepted"] !== undefined ? _data["isLicenseAccepted"] : null as any;
            this.isTcpProxyPrompted = _data["isTcpProxyPrompted"] !== undefined ? _data["isTcpProxyPrompted"] : null as any;
            this.isQuickLaunchPrompted = _data["isQuickLaunchPrompted"] !== undefined ? _data["isQuickLaunchPrompted"] : null as any;
            this.cultureCode = _data["cultureCode"] !== undefined ? _data["cultureCode"] : null as any;
            this.clientProfileId = _data["clientProfileId"] !== undefined ? _data["clientProfileId"] : null as any;
            this.maxPacketChannelCount = _data["maxPacketChannelCount"] !== undefined ? _data["maxPacketChannelCount"] : null as any;
            this.tunnelClientCountry = _data["tunnelClientCountry"] !== undefined ? _data["tunnelClientCountry"] : null as any;
            if (Array.isArray(_data["appFilters"])) {
                this.appFilters = [] as any;
                for (let item of _data["appFilters"])
                    this.appFilters!.push(item);
            }
            else {
                this.appFilters = null as any;
            }
            this.appFiltersMode = _data["appFiltersMode"] !== undefined ? _data["appFiltersMode"] : null as any;
            this.channelProtocol = _data["channelProtocol"] !== undefined ? _data["channelProtocol"] : null as any;
            this.dropUdp = _data["dropUdp"] !== undefined ? _data["dropUdp"] : null as any;
            this.useTcpProxy = _data["useTcpProxy"] !== undefined ? _data["useTcpProxy"] : null as any;
            this.dropQuic = _data["dropQuic"] !== undefined ? _data["dropQuic"] : null as any;
            this.allowAnonymousTracker = _data["allowAnonymousTracker"] !== undefined ? _data["allowAnonymousTracker"] : null as any;
            this.domainFilter = _data["domainFilter"] ? DomainFilter.fromJS(_data["domainFilter"]) : new DomainFilter();
            this.debugData1 = _data["debugData1"] !== undefined ? _data["debugData1"] : null as any;
            this.debugData2 = _data["debugData2"] !== undefined ? _data["debugData2"] : null as any;
            this.logAnonymous = _data["logAnonymous"] !== undefined ? _data["logAnonymous"] : null as any;
            this.includeLocalNetwork = _data["includeLocalNetwork"] !== undefined ? _data["includeLocalNetwork"] : null as any;
            this.useAppIpFilter = _data["useAppIpFilter"] !== undefined ? _data["useAppIpFilter"] : null as any;
            this.useVpnAdapterIpFilter = _data["useVpnAdapterIpFilter"] !== undefined ? _data["useVpnAdapterIpFilter"] : null as any;
            this.endPointStrategy = _data["endPointStrategy"] !== undefined ? _data["endPointStrategy"] : null as any;
            this.dnsMode = _data["dnsMode"] !== undefined ? _data["dnsMode"] : null as any;
            this.proxySettings = _data["proxySettings"] ? AppProxySettings.fromJS(_data["proxySettings"]) : new AppProxySettings();
            this.allowRemoteAccess = _data["allowRemoteAccess"] !== undefined ? _data["allowRemoteAccess"] : null as any;
            if (Array.isArray(_data["dnsServers"])) {
                this.dnsServers = [] as any;
                for (let item of _data["dnsServers"])
                    this.dnsServers!.push(item);
            }
            else {
                this.dnsServers = null as any;
            }
            this.useUdpChannel = _data["useUdpChannel"] !== undefined ? _data["useUdpChannel"] : null as any;
        }
    }

    static fromJS(data: any): UserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLicenseAccepted"] = this.isLicenseAccepted !== undefined ? this.isLicenseAccepted : null as any;
        data["isTcpProxyPrompted"] = this.isTcpProxyPrompted !== undefined ? this.isTcpProxyPrompted : null as any;
        data["isQuickLaunchPrompted"] = this.isQuickLaunchPrompted !== undefined ? this.isQuickLaunchPrompted : null as any;
        data["cultureCode"] = this.cultureCode !== undefined ? this.cultureCode : null as any;
        data["clientProfileId"] = this.clientProfileId !== undefined ? this.clientProfileId : null as any;
        data["maxPacketChannelCount"] = this.maxPacketChannelCount !== undefined ? this.maxPacketChannelCount : null as any;
        data["tunnelClientCountry"] = this.tunnelClientCountry !== undefined ? this.tunnelClientCountry : null as any;
        if (Array.isArray(this.appFilters)) {
            data["appFilters"] = [];
            for (let item of this.appFilters)
                data["appFilters"].push(item);
        }
        data["appFiltersMode"] = this.appFiltersMode !== undefined ? this.appFiltersMode : null as any;
        data["channelProtocol"] = this.channelProtocol !== undefined ? this.channelProtocol : null as any;
        data["dropUdp"] = this.dropUdp !== undefined ? this.dropUdp : null as any;
        data["useTcpProxy"] = this.useTcpProxy !== undefined ? this.useTcpProxy : null as any;
        data["dropQuic"] = this.dropQuic !== undefined ? this.dropQuic : null as any;
        data["allowAnonymousTracker"] = this.allowAnonymousTracker !== undefined ? this.allowAnonymousTracker : null as any;
        data["domainFilter"] = this.domainFilter ? this.domainFilter.toJSON() : null as any;
        data["debugData1"] = this.debugData1 !== undefined ? this.debugData1 : null as any;
        data["debugData2"] = this.debugData2 !== undefined ? this.debugData2 : null as any;
        data["logAnonymous"] = this.logAnonymous !== undefined ? this.logAnonymous : null as any;
        data["includeLocalNetwork"] = this.includeLocalNetwork !== undefined ? this.includeLocalNetwork : null as any;
        data["useAppIpFilter"] = this.useAppIpFilter !== undefined ? this.useAppIpFilter : null as any;
        data["useVpnAdapterIpFilter"] = this.useVpnAdapterIpFilter !== undefined ? this.useVpnAdapterIpFilter : null as any;
        data["endPointStrategy"] = this.endPointStrategy !== undefined ? this.endPointStrategy : null as any;
        data["dnsMode"] = this.dnsMode !== undefined ? this.dnsMode : null as any;
        data["proxySettings"] = this.proxySettings ? this.proxySettings.toJSON() : null as any;
        data["allowRemoteAccess"] = this.allowRemoteAccess !== undefined ? this.allowRemoteAccess : null as any;
        if (Array.isArray(this.dnsServers)) {
            data["dnsServers"] = [];
            for (let item of this.dnsServers)
                data["dnsServers"].push(item);
        }
        data["useUdpChannel"] = this.useUdpChannel !== undefined ? this.useUdpChannel : null as any;
        return data;
    }
}

export interface IUserSettings {
    isLicenseAccepted: boolean;
    isTcpProxyPrompted: boolean;
    isQuickLaunchPrompted: boolean;
    cultureCode?: string | null;
    clientProfileId?: string | null;
    maxPacketChannelCount: number;
    tunnelClientCountry: boolean;
    appFilters: string[];
    appFiltersMode: FilterMode;
    channelProtocol: ChannelProtocol;
    dropUdp: boolean;
    useTcpProxy: boolean;
    dropQuic: boolean;
    allowAnonymousTracker: boolean;
    domainFilter: DomainFilter;
    debugData1?: string | null;
    debugData2?: string | null;
    logAnonymous: boolean;
    includeLocalNetwork: boolean;
    useAppIpFilter: boolean;
    useVpnAdapterIpFilter: boolean;
    endPointStrategy: EndPointStrategy;
    dnsMode: DnsMode;
    proxySettings: AppProxySettings;
    allowRemoteAccess: boolean;
    dnsServers: string[];
    useUdpChannel?: boolean | null;
}

export enum FilterMode {
    All = "All",
    Exclude = "Exclude",
    Include = "Include",
}

export class DomainFilter implements IDomainFilter {
    blocks!: string[];
    excludes!: string[];
    includes!: string[];

    constructor(data?: IDomainFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.blocks = [];
            this.excludes = [];
            this.includes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["blocks"])) {
                this.blocks = [] as any;
                for (let item of _data["blocks"])
                    this.blocks!.push(item);
            }
            else {
                this.blocks = null as any;
            }
            if (Array.isArray(_data["excludes"])) {
                this.excludes = [] as any;
                for (let item of _data["excludes"])
                    this.excludes!.push(item);
            }
            else {
                this.excludes = null as any;
            }
            if (Array.isArray(_data["includes"])) {
                this.includes = [] as any;
                for (let item of _data["includes"])
                    this.includes!.push(item);
            }
            else {
                this.includes = null as any;
            }
        }
    }

    static fromJS(data: any): DomainFilter {
        data = typeof data === 'object' ? data : {};
        let result = new DomainFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.blocks)) {
            data["blocks"] = [];
            for (let item of this.blocks)
                data["blocks"].push(item);
        }
        if (Array.isArray(this.excludes)) {
            data["excludes"] = [];
            for (let item of this.excludes)
                data["excludes"].push(item);
        }
        if (Array.isArray(this.includes)) {
            data["includes"] = [];
            for (let item of this.includes)
                data["includes"].push(item);
        }
        return data;
    }
}

export interface IDomainFilter {
    blocks: string[];
    excludes: string[];
    includes: string[];
}

export enum EndPointStrategy {
    Auto = "Auto",
    DnsFirst = "DnsFirst",
    TokenFirst = "TokenFirst",
    DnsOnly = "DnsOnly",
    TokenOnly = "TokenOnly",
}

export enum DnsMode {
    Default = "Default",
    AdapterDns = "AdapterDns",
}

export class AppProxySettings implements IAppProxySettings {
    mode!: AppProxyMode;
    autoUpdateListUrl?: string | null;
    autoUpdateInterval?: string | null;
    autoUpdateMinPenalty!: number;

    constructor(data?: IAppProxySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mode = _data["mode"] !== undefined ? _data["mode"] : null as any;
            this.autoUpdateListUrl = _data["autoUpdateListUrl"] !== undefined ? _data["autoUpdateListUrl"] : null as any;
            this.autoUpdateInterval = _data["autoUpdateInterval"] !== undefined ? _data["autoUpdateInterval"] : null as any;
            this.autoUpdateMinPenalty = _data["autoUpdateMinPenalty"] !== undefined ? _data["autoUpdateMinPenalty"] : null as any;
        }
    }

    static fromJS(data: any): AppProxySettings {
        data = typeof data === 'object' ? data : {};
        let result = new AppProxySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mode"] = this.mode !== undefined ? this.mode : null as any;
        data["autoUpdateListUrl"] = this.autoUpdateListUrl !== undefined ? this.autoUpdateListUrl : null as any;
        data["autoUpdateInterval"] = this.autoUpdateInterval !== undefined ? this.autoUpdateInterval : null as any;
        data["autoUpdateMinPenalty"] = this.autoUpdateMinPenalty !== undefined ? this.autoUpdateMinPenalty : null as any;
        return data;
    }
}

export interface IAppProxySettings {
    mode: AppProxyMode;
    autoUpdateListUrl?: string | null;
    autoUpdateInterval?: string | null;
    autoUpdateMinPenalty: number;
}

export enum AppProxyMode {
    NoProxy = 0,
    Device = 1,
    Manual = 2,
}

export class ClientProfileInfo implements IClientProfileInfo {
    clientProfileId!: string;
    clientProfileName!: string;
    supportId?: string | null;
    customData?: string | null;
    isPremiumLocationSelected!: boolean;
    isPremiumAccount!: boolean;
    tokenId!: string;
    hostNames!: string[];
    isValidHostName!: boolean;
    isBuiltIn!: boolean;
    isForAccount!: boolean;
    accessCode?: string | null;
    locationInfos!: ClientServerLocationInfo[];
    purchaseUrl?: string | null;
    purchaseUrlMode!: PurchaseUrlMode;
    customServerEndpoints?: string[] | null;
    selectedLocationInfo?: ClientServerLocationInfo | null;

    constructor(data?: IClientProfileInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.hostNames = [];
            this.locationInfos = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileId = _data["clientProfileId"] !== undefined ? _data["clientProfileId"] : null as any;
            this.clientProfileName = _data["clientProfileName"] !== undefined ? _data["clientProfileName"] : null as any;
            this.supportId = _data["supportId"] !== undefined ? _data["supportId"] : null as any;
            this.customData = _data["customData"] !== undefined ? _data["customData"] : null as any;
            this.isPremiumLocationSelected = _data["isPremiumLocationSelected"] !== undefined ? _data["isPremiumLocationSelected"] : null as any;
            this.isPremiumAccount = _data["isPremiumAccount"] !== undefined ? _data["isPremiumAccount"] : null as any;
            this.tokenId = _data["tokenId"] !== undefined ? _data["tokenId"] : null as any;
            if (Array.isArray(_data["hostNames"])) {
                this.hostNames = [] as any;
                for (let item of _data["hostNames"])
                    this.hostNames!.push(item);
            }
            else {
                this.hostNames = null as any;
            }
            this.isValidHostName = _data["isValidHostName"] !== undefined ? _data["isValidHostName"] : null as any;
            this.isBuiltIn = _data["isBuiltIn"] !== undefined ? _data["isBuiltIn"] : null as any;
            this.isForAccount = _data["isForAccount"] !== undefined ? _data["isForAccount"] : null as any;
            this.accessCode = _data["accessCode"] !== undefined ? _data["accessCode"] : null as any;
            if (Array.isArray(_data["locationInfos"])) {
                this.locationInfos = [] as any;
                for (let item of _data["locationInfos"])
                    this.locationInfos!.push(ClientServerLocationInfo.fromJS(item));
            }
            else {
                this.locationInfos = null as any;
            }
            this.purchaseUrl = _data["purchaseUrl"] !== undefined ? _data["purchaseUrl"] : null as any;
            this.purchaseUrlMode = _data["purchaseUrlMode"] !== undefined ? _data["purchaseUrlMode"] : null as any;
            if (Array.isArray(_data["customServerEndpoints"])) {
                this.customServerEndpoints = [] as any;
                for (let item of _data["customServerEndpoints"])
                    this.customServerEndpoints!.push(item);
            }
            else {
                this.customServerEndpoints = null as any;
            }
            this.selectedLocationInfo = _data["selectedLocationInfo"] ? ClientServerLocationInfo.fromJS(_data["selectedLocationInfo"]) : null as any;
        }
    }

    static fromJS(data: any): ClientProfileInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileId"] = this.clientProfileId !== undefined ? this.clientProfileId : null as any;
        data["clientProfileName"] = this.clientProfileName !== undefined ? this.clientProfileName : null as any;
        data["supportId"] = this.supportId !== undefined ? this.supportId : null as any;
        data["customData"] = this.customData !== undefined ? this.customData : null as any;
        data["isPremiumLocationSelected"] = this.isPremiumLocationSelected !== undefined ? this.isPremiumLocationSelected : null as any;
        data["isPremiumAccount"] = this.isPremiumAccount !== undefined ? this.isPremiumAccount : null as any;
        data["tokenId"] = this.tokenId !== undefined ? this.tokenId : null as any;
        if (Array.isArray(this.hostNames)) {
            data["hostNames"] = [];
            for (let item of this.hostNames)
                data["hostNames"].push(item);
        }
        data["isValidHostName"] = this.isValidHostName !== undefined ? this.isValidHostName : null as any;
        data["isBuiltIn"] = this.isBuiltIn !== undefined ? this.isBuiltIn : null as any;
        data["isForAccount"] = this.isForAccount !== undefined ? this.isForAccount : null as any;
        data["accessCode"] = this.accessCode !== undefined ? this.accessCode : null as any;
        if (Array.isArray(this.locationInfos)) {
            data["locationInfos"] = [];
            for (let item of this.locationInfos)
                data["locationInfos"].push(item ? item.toJSON() : null as any);
        }
        data["purchaseUrl"] = this.purchaseUrl !== undefined ? this.purchaseUrl : null as any;
        data["purchaseUrlMode"] = this.purchaseUrlMode !== undefined ? this.purchaseUrlMode : null as any;
        if (Array.isArray(this.customServerEndpoints)) {
            data["customServerEndpoints"] = [];
            for (let item of this.customServerEndpoints)
                data["customServerEndpoints"].push(item);
        }
        data["selectedLocationInfo"] = this.selectedLocationInfo ? this.selectedLocationInfo.toJSON() : null as any;
        return data;
    }
}

export interface IClientProfileInfo {
    clientProfileId: string;
    clientProfileName: string;
    supportId?: string | null;
    customData?: string | null;
    isPremiumLocationSelected: boolean;
    isPremiumAccount: boolean;
    tokenId: string;
    hostNames: string[];
    isValidHostName: boolean;
    isBuiltIn: boolean;
    isForAccount: boolean;
    accessCode?: string | null;
    locationInfos: ClientServerLocationInfo[];
    purchaseUrl?: string | null;
    purchaseUrlMode: PurchaseUrlMode;
    customServerEndpoints?: string[] | null;
    selectedLocationInfo?: ClientServerLocationInfo | null;
}

export enum PurchaseUrlMode {
    WhenNoStore = 0,
    WithStore = 1,
    HideStore = 2,
}

export class ConfigParams implements IConfigParams {
    availableCultures!: string[];
    strings?: AppStrings | null;

    constructor(data?: IConfigParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.availableCultures = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["availableCultures"])) {
                this.availableCultures = [] as any;
                for (let item of _data["availableCultures"])
                    this.availableCultures!.push(item);
            }
            else {
                this.availableCultures = null as any;
            }
            this.strings = _data["strings"] ? AppStrings.fromJS(_data["strings"]) : null as any;
        }
    }

    static fromJS(data: any): ConfigParams {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.availableCultures)) {
            data["availableCultures"] = [];
            for (let item of this.availableCultures)
                data["availableCultures"].push(item);
        }
        data["strings"] = this.strings ? this.strings.toJSON() : null as any;
        return data;
    }
}

export interface IConfigParams {
    availableCultures: string[];
    strings?: AppStrings | null;
}

export class AppStrings implements IAppStrings {
    appName!: string;
    disconnect!: string;
    connect!: string;
    disconnected!: string;
    exit!: string;
    manage!: string;
    msgAccessKeyAdded!: string;
    msgAccessKeyUpdated!: string;
    msgCantReadAccessKey!: string;
    msgUnsupportedContent!: string;
    open!: string;
    openInBrowser!: string;

    constructor(data?: IAppStrings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appName = _data["appName"] !== undefined ? _data["appName"] : null as any;
            this.disconnect = _data["disconnect"] !== undefined ? _data["disconnect"] : null as any;
            this.connect = _data["connect"] !== undefined ? _data["connect"] : null as any;
            this.disconnected = _data["disconnected"] !== undefined ? _data["disconnected"] : null as any;
            this.exit = _data["exit"] !== undefined ? _data["exit"] : null as any;
            this.manage = _data["manage"] !== undefined ? _data["manage"] : null as any;
            this.msgAccessKeyAdded = _data["msgAccessKeyAdded"] !== undefined ? _data["msgAccessKeyAdded"] : null as any;
            this.msgAccessKeyUpdated = _data["msgAccessKeyUpdated"] !== undefined ? _data["msgAccessKeyUpdated"] : null as any;
            this.msgCantReadAccessKey = _data["msgCantReadAccessKey"] !== undefined ? _data["msgCantReadAccessKey"] : null as any;
            this.msgUnsupportedContent = _data["msgUnsupportedContent"] !== undefined ? _data["msgUnsupportedContent"] : null as any;
            this.open = _data["open"] !== undefined ? _data["open"] : null as any;
            this.openInBrowser = _data["openInBrowser"] !== undefined ? _data["openInBrowser"] : null as any;
        }
    }

    static fromJS(data: any): AppStrings {
        data = typeof data === 'object' ? data : {};
        let result = new AppStrings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName !== undefined ? this.appName : null as any;
        data["disconnect"] = this.disconnect !== undefined ? this.disconnect : null as any;
        data["connect"] = this.connect !== undefined ? this.connect : null as any;
        data["disconnected"] = this.disconnected !== undefined ? this.disconnected : null as any;
        data["exit"] = this.exit !== undefined ? this.exit : null as any;
        data["manage"] = this.manage !== undefined ? this.manage : null as any;
        data["msgAccessKeyAdded"] = this.msgAccessKeyAdded !== undefined ? this.msgAccessKeyAdded : null as any;
        data["msgAccessKeyUpdated"] = this.msgAccessKeyUpdated !== undefined ? this.msgAccessKeyUpdated : null as any;
        data["msgCantReadAccessKey"] = this.msgCantReadAccessKey !== undefined ? this.msgCantReadAccessKey : null as any;
        data["msgUnsupportedContent"] = this.msgUnsupportedContent !== undefined ? this.msgUnsupportedContent : null as any;
        data["open"] = this.open !== undefined ? this.open : null as any;
        data["openInBrowser"] = this.openInBrowser !== undefined ? this.openInBrowser : null as any;
        return data;
    }
}

export interface IAppStrings {
    appName: string;
    disconnect: string;
    connect: string;
    disconnected: string;
    exit: string;
    manage: string;
    msgAccessKeyAdded: string;
    msgAccessKeyUpdated: string;
    msgCantReadAccessKey: string;
    msgUnsupportedContent: string;
    open: string;
    openInBrowser: string;
}

export class IpFilters implements IIpFilters {
    adapterIpFilterIncludes!: string;
    adapterIpFilterExcludes!: string;
    appIpFilterIncludes!: string;
    appIpFilterExcludes!: string;

    constructor(data?: IIpFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adapterIpFilterIncludes = _data["adapterIpFilterIncludes"] !== undefined ? _data["adapterIpFilterIncludes"] : null as any;
            this.adapterIpFilterExcludes = _data["adapterIpFilterExcludes"] !== undefined ? _data["adapterIpFilterExcludes"] : null as any;
            this.appIpFilterIncludes = _data["appIpFilterIncludes"] !== undefined ? _data["appIpFilterIncludes"] : null as any;
            this.appIpFilterExcludes = _data["appIpFilterExcludes"] !== undefined ? _data["appIpFilterExcludes"] : null as any;
        }
    }

    static fromJS(data: any): IpFilters {
        data = typeof data === 'object' ? data : {};
        let result = new IpFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adapterIpFilterIncludes"] = this.adapterIpFilterIncludes !== undefined ? this.adapterIpFilterIncludes : null as any;
        data["adapterIpFilterExcludes"] = this.adapterIpFilterExcludes !== undefined ? this.adapterIpFilterExcludes : null as any;
        data["appIpFilterIncludes"] = this.appIpFilterIncludes !== undefined ? this.appIpFilterIncludes : null as any;
        data["appIpFilterExcludes"] = this.appIpFilterExcludes !== undefined ? this.appIpFilterExcludes : null as any;
        return data;
    }
}

export interface IIpFilters {
    adapterIpFilterIncludes: string;
    adapterIpFilterExcludes: string;
    appIpFilterIncludes: string;
    appIpFilterExcludes: string;
}

export enum ConnectPlanId {
    Normal = "Normal",
    PremiumByTrial = "PremiumByTrial",
    PremiumByRewardedAd = "PremiumByRewardedAd",
    Status = "Status",
}

export class DeviceAppInfo implements IDeviceAppInfo {
    appId!: string;
    appName!: string;
    iconPng!: string;

    constructor(data?: IDeviceAppInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"] !== undefined ? _data["appId"] : null as any;
            this.appName = _data["appName"] !== undefined ? _data["appName"] : null as any;
            this.iconPng = _data["iconPng"] !== undefined ? _data["iconPng"] : null as any;
        }
    }

    static fromJS(data: any): DeviceAppInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAppInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId !== undefined ? this.appId : null as any;
        data["appName"] = this.appName !== undefined ? this.appName : null as any;
        data["iconPng"] = this.iconPng !== undefined ? this.iconPng : null as any;
        return data;
    }
}

export interface IDeviceAppInfo {
    appId: string;
    appName: string;
    iconPng: string;
}

export enum ExceptionType {
    NoErrorFound = "NoErrorFoundException",
    Maintenance = "MaintenanceException",
    Session = "SessionException",
    Ad = "AdException",
    ShowAd = "ShowAdException",
    ShowAdNoUi = "ShowAdNoUiException",
    LoadAd = "LoadAdException",
    NoInternet = "NoInternetException",
    NoStableVpn = "NoStableVpnException",
    UnreachableServer = "UnreachableServerException",
    UnreachableProxyServer = "UnreachableProxyServerException",
    UnreachableServerLocation = "UnreachableServerLocationException",
    RewardNotEarned = "RewardNotEarnedException",
    VpnServiceNotReady = "VpnServiceNotReadyException",
    VpnServiceUnreachable = "VpnServiceUnreachableException",
    VpnServiceTimeout = "VpnServiceTimeoutException",
    VpnService = "VpnServiceNotReadyException",
    UserCanceled = "UserCanceledException",
    ConnectionTimeout = "ConnectionTimeoutException",
    EndPointDiscovery = "EndPointDiscoveryException",
    PremiumOnly = "PremiumOnlyException",
    AdBlocker = "AdBlockerException",
    RequestQuickLaunch = "RequestQuickLaunchException",
    VpnServiceRevoked = "VpnServiceRevokedException",
}

export enum SessionErrorCode {
    Ok = "Ok",
    AccessError = "AccessError",
    PlanRejected = "PlanRejected",
    GeneralError = "GeneralError",
    SessionClosed = "SessionClosed",
    SessionSuppressedBy = "SessionSuppressedBy",
    SessionError = "SessionError",
    SessionExpired = "SessionExpired",
    AccessExpired = "AccessExpired",
    AccessCodeRejected = "AccessCodeRejected",
    AccessLocked = "AccessLocked",
    AccessTrafficOverflow = "AccessTrafficOverflow",
    DailyLimitExceeded = "DailyLimitExceeded",
    NoServerAvailable = "NoServerAvailable",
    PremiumLocation = "PremiumLocation",
    AdError = "AdError",
    RewardedAdRejected = "RewardedAdRejected",
    Maintenance = "Maintenance",
    RedirectHost = "RedirectHost",
    UnsupportedClient = "UnsupportedClient",
    UnsupportedServer = "UnsupportedServer",
}

export class AppUserReview implements IAppUserReview {
    rating!: number;
    reviewText!: string;

    constructor(data?: IAppUserReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null as any;
            this.reviewText = _data["reviewText"] !== undefined ? _data["reviewText"] : null as any;
        }
    }

    static fromJS(data: any): AppUserReview {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rating"] = this.rating !== undefined ? this.rating : null as any;
        data["reviewText"] = this.reviewText !== undefined ? this.reviewText : null as any;
        return data;
    }
}

export interface IAppUserReview {
    rating: number;
    reviewText: string;
}

export class CountryInfo implements ICountryInfo {
    englishName!: string;
    countryCode!: string;

    constructor(data?: ICountryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.englishName = _data["englishName"] !== undefined ? _data["englishName"] : null as any;
            this.countryCode = _data["countryCode"] !== undefined ? _data["countryCode"] : null as any;
        }
    }

    static fromJS(data: any): CountryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CountryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["englishName"] = this.englishName !== undefined ? this.englishName : null as any;
        data["countryCode"] = this.countryCode !== undefined ? this.countryCode : null as any;
        return data;
    }
}

export interface ICountryInfo {
    englishName: string;
    countryCode: string;
}

export enum ShowAdResult {
    Closed = "Closed",
    Clicked = "Clicked",
}

export class SubscriptionPlan implements ISubscriptionPlan {
    subscriptionPlanId!: string;
    planPrice!: string;

    constructor(data?: ISubscriptionPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionPlanId = _data["subscriptionPlanId"] !== undefined ? _data["subscriptionPlanId"] : null as any;
            this.planPrice = _data["planPrice"] !== undefined ? _data["planPrice"] : null as any;
        }
    }

    static fromJS(data: any): SubscriptionPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPlanId"] = this.subscriptionPlanId !== undefined ? this.subscriptionPlanId : null as any;
        data["planPrice"] = this.planPrice !== undefined ? this.planPrice : null as any;
        return data;
    }
}

export interface ISubscriptionPlan {
    subscriptionPlanId: string;
    planPrice: string;
}

export class AppPurchaseOptions implements IAppPurchaseOptions {
    storeName?: string | null;
    storeError?: ApiError | null;
    subscriptionPlans!: SubscriptionPlan[];
    purchaseUrl?: string | null;

    constructor(data?: IAppPurchaseOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.subscriptionPlans = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeName = _data["storeName"] !== undefined ? _data["storeName"] : null as any;
            this.storeError = _data["storeError"] ? ApiError.fromJS(_data["storeError"]) : null as any;
            if (Array.isArray(_data["subscriptionPlans"])) {
                this.subscriptionPlans = [] as any;
                for (let item of _data["subscriptionPlans"])
                    this.subscriptionPlans!.push(SubscriptionPlan.fromJS(item));
            }
            else {
                this.subscriptionPlans = null as any;
            }
            this.purchaseUrl = _data["purchaseUrl"] !== undefined ? _data["purchaseUrl"] : null as any;
        }
    }

    static fromJS(data: any): AppPurchaseOptions {
        data = typeof data === 'object' ? data : {};
        let result = new AppPurchaseOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeName"] = this.storeName !== undefined ? this.storeName : null as any;
        data["storeError"] = this.storeError ? this.storeError.toJSON() : null as any;
        if (Array.isArray(this.subscriptionPlans)) {
            data["subscriptionPlans"] = [];
            for (let item of this.subscriptionPlans)
                data["subscriptionPlans"].push(item ? item.toJSON() : null as any);
        }
        data["purchaseUrl"] = this.purchaseUrl !== undefined ? this.purchaseUrl : null as any;
        return data;
    }
}

export interface IAppPurchaseOptions {
    storeName?: string | null;
    storeError?: ApiError | null;
    subscriptionPlans: SubscriptionPlan[];
    purchaseUrl?: string | null;
}

export class ClientProfileUpdateParams implements IClientProfileUpdateParams {
    clientProfileName?: PatchOfString | null;
    isFavorite?: PatchOfBoolean | null;
    selectedLocation?: PatchOfString | null;
    customData?: PatchOfString | null;
    isPremiumLocationSelected?: PatchOfBoolean | null;
    accessCode?: PatchOfString | null;
    customServerEndpoints?: PatchOfStringOf | null;

    constructor(data?: IClientProfileUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientProfileName = _data["clientProfileName"] ? PatchOfString.fromJS(_data["clientProfileName"]) : null as any;
            this.isFavorite = _data["isFavorite"] ? PatchOfBoolean.fromJS(_data["isFavorite"]) : null as any;
            this.selectedLocation = _data["selectedLocation"] ? PatchOfString.fromJS(_data["selectedLocation"]) : null as any;
            this.customData = _data["customData"] ? PatchOfString.fromJS(_data["customData"]) : null as any;
            this.isPremiumLocationSelected = _data["isPremiumLocationSelected"] ? PatchOfBoolean.fromJS(_data["isPremiumLocationSelected"]) : null as any;
            this.accessCode = _data["accessCode"] ? PatchOfString.fromJS(_data["accessCode"]) : null as any;
            this.customServerEndpoints = _data["customServerEndpoints"] ? PatchOfStringOf.fromJS(_data["customServerEndpoints"]) : null as any;
        }
    }

    static fromJS(data: any): ClientProfileUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ClientProfileUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientProfileName"] = this.clientProfileName ? this.clientProfileName.toJSON() : null as any;
        data["isFavorite"] = this.isFavorite ? this.isFavorite.toJSON() : null as any;
        data["selectedLocation"] = this.selectedLocation ? this.selectedLocation.toJSON() : null as any;
        data["customData"] = this.customData ? this.customData.toJSON() : null as any;
        data["isPremiumLocationSelected"] = this.isPremiumLocationSelected ? this.isPremiumLocationSelected.toJSON() : null as any;
        data["accessCode"] = this.accessCode ? this.accessCode.toJSON() : null as any;
        data["customServerEndpoints"] = this.customServerEndpoints ? this.customServerEndpoints.toJSON() : null as any;
        return data;
    }
}

export interface IClientProfileUpdateParams {
    clientProfileName?: PatchOfString | null;
    isFavorite?: PatchOfBoolean | null;
    selectedLocation?: PatchOfString | null;
    customData?: PatchOfString | null;
    isPremiumLocationSelected?: PatchOfBoolean | null;
    accessCode?: PatchOfString | null;
    customServerEndpoints?: PatchOfStringOf | null;
}

export class PatchOfString implements IPatchOfString {
    value?: string | null;

    constructor(data?: IPatchOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : null as any;
        }
    }

    static fromJS(data: any): PatchOfString {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : null as any;
        return data;
    }
}

export interface IPatchOfString {
    value?: string | null;
}

export class PatchOfBoolean implements IPatchOfBoolean {
    value!: boolean;

    constructor(data?: IPatchOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : null as any;
        }
    }

    static fromJS(data: any): PatchOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : null as any;
        return data;
    }
}

export interface IPatchOfBoolean {
    value: boolean;
}

export class PatchOfStringOf implements IPatchOfStringOf {
    value?: string[] | null;

    constructor(data?: IPatchOfStringOf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            else {
                this.value = null as any;
            }
        }
    }

    static fromJS(data: any): PatchOfStringOf {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfStringOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export interface IPatchOfStringOf {
    value?: string[] | null;
}

export class ProxyEndPointInfo implements IProxyEndPointInfo {
    endPoint!: ProxyEndPoint;
    status!: ProxyEndPointStatus;

    constructor(data?: IProxyEndPointInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.endPoint = new ProxyEndPoint();
            this.status = new ProxyEndPointStatus();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.endPoint = _data["endPoint"] ? ProxyEndPoint.fromJS(_data["endPoint"]) : new ProxyEndPoint();
            this.status = _data["status"] ? ProxyEndPointStatus.fromJS(_data["status"]) : new ProxyEndPointStatus();
        }
    }

    static fromJS(data: any): ProxyEndPointInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyEndPointInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endPoint"] = this.endPoint ? this.endPoint.toJSON() : null as any;
        data["status"] = this.status ? this.status.toJSON() : null as any;
        return data;
    }
}

export interface IProxyEndPointInfo {
    endPoint: ProxyEndPoint;
    status: ProxyEndPointStatus;
}

export class AppProxyEndPointInfo extends ProxyEndPointInfo implements IAppProxyEndPointInfo {
    countryCode?: string | null;

    constructor(data?: IAppProxyEndPointInfo) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.countryCode = _data["countryCode"] !== undefined ? _data["countryCode"] : null as any;
        }
    }

    static override fromJS(data: any): AppProxyEndPointInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AppProxyEndPointInfo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode !== undefined ? this.countryCode : null as any;
        super.toJSON(data);
        return data;
    }
}

export interface IAppProxyEndPointInfo extends IProxyEndPointInfo {
    countryCode?: string | null;
}

export class ProxyEndPoint implements IProxyEndPoint {
    id!: string;
    isEnabled!: boolean;
    protocol!: ProxyProtocol;
    host!: string;
    port!: number;
    username?: string | null;
    password?: string | null;
    url!: string;

    constructor(data?: IProxyEndPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.isEnabled = _data["isEnabled"] !== undefined ? _data["isEnabled"] : null as any;
            this.protocol = _data["protocol"] !== undefined ? _data["protocol"] : null as any;
            this.host = _data["host"] !== undefined ? _data["host"] : null as any;
            this.port = _data["port"] !== undefined ? _data["port"] : null as any;
            this.username = _data["username"] !== undefined ? _data["username"] : null as any;
            this.password = _data["password"] !== undefined ? _data["password"] : null as any;
            this.url = _data["url"] !== undefined ? _data["url"] : null as any;
        }
    }

    static fromJS(data: any): ProxyEndPoint {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyEndPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["isEnabled"] = this.isEnabled !== undefined ? this.isEnabled : null as any;
        data["protocol"] = this.protocol !== undefined ? this.protocol : null as any;
        data["host"] = this.host !== undefined ? this.host : null as any;
        data["port"] = this.port !== undefined ? this.port : null as any;
        data["username"] = this.username !== undefined ? this.username : null as any;
        data["password"] = this.password !== undefined ? this.password : null as any;
        data["url"] = this.url !== undefined ? this.url : null as any;
        return data;
    }
}

export interface IProxyEndPoint {
    id: string;
    isEnabled: boolean;
    protocol: ProxyProtocol;
    host: string;
    port: number;
    username?: string | null;
    password?: string | null;
    url: string;
}

export enum ProxyProtocol {
    Socks4 = "Socks4",
    Socks5 = "Socks5",
    Http = "Http",
    Https = "Https",
}

export class ProxyEndPointStatus implements IProxyEndPointStatus {
    penalty!: number;
    succeededCount!: number;
    failedCount!: number;
    latency?: string | null;
    lastUsedTime?: Date | null;
    errorMessage?: string | null;

    constructor(data?: IProxyEndPointStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.penalty = _data["penalty"] !== undefined ? _data["penalty"] : null as any;
            this.succeededCount = _data["succeededCount"] !== undefined ? _data["succeededCount"] : null as any;
            this.failedCount = _data["failedCount"] !== undefined ? _data["failedCount"] : null as any;
            this.latency = _data["latency"] !== undefined ? _data["latency"] : null as any;
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : null as any;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : null as any;
        }
    }

    static fromJS(data: any): ProxyEndPointStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyEndPointStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["penalty"] = this.penalty !== undefined ? this.penalty : null as any;
        data["succeededCount"] = this.succeededCount !== undefined ? this.succeededCount : null as any;
        data["failedCount"] = this.failedCount !== undefined ? this.failedCount : null as any;
        data["latency"] = this.latency !== undefined ? this.latency : null as any;
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : null as any;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null as any;
        return data;
    }
}

export interface IProxyEndPointStatus {
    penalty: number;
    succeededCount: number;
    failedCount: number;
    latency?: string | null;
    lastUsedTime?: Date | null;
    errorMessage?: string | null;
}

export class ProxyEndPointDefaults implements IProxyEndPointDefaults {
    isEnabled?: boolean | null;
    protocol?: ProxyProtocol | null;
    port?: number | null;
    username?: string | null;
    password?: string | null;

    constructor(data?: IProxyEndPointDefaults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"] !== undefined ? _data["isEnabled"] : null as any;
            this.protocol = _data["protocol"] !== undefined ? _data["protocol"] : null as any;
            this.port = _data["port"] !== undefined ? _data["port"] : null as any;
            this.username = _data["username"] !== undefined ? _data["username"] : null as any;
            this.password = _data["password"] !== undefined ? _data["password"] : null as any;
        }
    }

    static fromJS(data: any): ProxyEndPointDefaults {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyEndPointDefaults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled !== undefined ? this.isEnabled : null as any;
        data["protocol"] = this.protocol !== undefined ? this.protocol : null as any;
        data["port"] = this.port !== undefined ? this.port : null as any;
        data["username"] = this.username !== undefined ? this.username : null as any;
        data["password"] = this.password !== undefined ? this.password : null as any;
        return data;
    }
}

export interface IProxyEndPointDefaults {
    isEnabled?: boolean | null;
    protocol?: ProxyProtocol | null;
    port?: number | null;
    username?: string | null;
    password?: string | null;
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

export class ApiException extends Error {
    statusCode: number;
    response: string | null;
    exceptionTypeName: string | null = null;
    exceptionTypeFullName: string | null = null;
    headers: unknown;
    data: { [key: string]: unknown } = {};

    constructor(
        message: string,
        statusCode: number,
        response?: unknown,
        headers?: unknown,
        innerException?: Error | null
    ) {
        const apiError = ApiException.getApiError(response);

        // Let have response as string to show in toString
        const responseStr: string | null = response instanceof String || typeof response === 'string'
            ? response.toString() : JSON.stringify(response);

        // Call super with build message
        super(ApiException.buildMessage(apiError, message, statusCode, responseStr));

        // Set properties
        this.statusCode = statusCode;
        this.response = responseStr;
        this.headers = headers;

        // Try copy data from ApiError
        if (apiError) {
            Object.keys(apiError.data).forEach((key) => {
                if (apiError)
                    this.data[key] = apiError.data[key];
            });
            this.exceptionTypeName = apiError.typeName;
            this.exceptionTypeFullName = apiError.typeFullName;
        }

        if (innerException) {
            this.stack = innerException.stack;
        }
    }

    // Try to convert an ApiError to an ApiException. it usually comes from unknown type
    public static fromApiError(apiError: unknown): ApiException {
        if (!apiError)
            throw new Error('apiError can not be null!');

        const apiErrorObj = this.getApiError(apiError);
        return new ApiException(apiErrorObj?.message || 'Unknown Error!', 500, apiError, null, null);
    }

    private static buildMessage(
        apiError: IApiErrorCamel | null,
        message: string,
        statusCode: number,
        response: string | null
    ): string {
        if (apiError)
            return apiError.message || '';

        return `${message}\n\nStatus: ${statusCode}\nResponse:\n${response?.substring(0, Math.min(512, response.length))}`;
    }

    override toString(): string {
        return `HTTP Response:\n\n${this.response}\n\n${super.toString()}`;
    }

    private static getApiError(apiError: unknown): IApiErrorCamel | null {
        if (!apiError)
            return null;

        // Check if it's a string and try to parse it
        if (typeof apiError === 'string') {
            try {
                apiError = JSON.parse(apiError);
            } catch {
                return null;
            }
        }

        // Check if it's a camelCase object by looking for typeName
        const apiErrorCamel: IApiErrorCamel = apiError as IApiErrorCamel;
        if (apiErrorCamel.typeName) {
            return {
                data: apiErrorCamel.data || {},
                typeName: apiErrorCamel.typeName || null,
                typeFullName: apiErrorCamel.typeFullName || null,
                message: apiErrorCamel.message || null
            };
        }

        // Check if it's a PascalCase object by looking for TypeName
        const apiErrorPascal: IApiErrorPascal = apiError as IApiErrorPascal;
        if (apiErrorPascal.TypeName) {
            return {
                data: apiErrorPascal.Data || {},
                typeName: apiErrorPascal.TypeName || null,
                typeFullName: apiErrorPascal.TypeFullName || null,
                message: apiErrorPascal.Message || null
            };
        }

        // Return null if not a valid PascalCase object
        return null;
    }
}

interface IApiErrorCamel {
    data: { [key: string]: unknown };
    typeName: string | null;
    typeFullName: string | null;
    message: string | null;
}
interface IApiErrorPascal {
    Data: { [key: string]: unknown };
    TypeName: string | null;
    TypeFullName: string | null;
    Message: string | null;
}